---
title: Covid-19 isolation and quarantine orders in a district of Berlin, Germany How many, how long, to whom and predictive factors
date: "`r format(Sys.time(), '%d. %B %Y')`"
author: Jakob Schumacher, Lisa Kühne, Sophie Bruessermann, Benjamin Geisler, Sonja Jäckle
output:
  html_document:
    df_print: paged
    toc: FALSE
    toc_float: FALSE
    theme: lumen
    code_folding: hide
    number_sections: true
    fig_caption: true
  bookdown::html_document2:
    df_print: paged
  pdf_document:
    keep_tex: yes
params:
  completerun: FALSE
  dataversion: "2022-04-14"
---
![](https://www.horizont.net/news/media/32/Das-neue-Berlin-Logo-315209.jpeg){width=30%}
![](https://www.ultrasoundsymposium.org/wp-content/uploads/2017/08/fhg-1.gif){width=30%}
![](https://www.lsc-digital-public-health.de/images/partners/leibniz-institut-bips.png){width=30%}

# About this Repository
The following R-Script calculates all the necessary numbers and figures for a publication. All necessary files to reproduce are available. 

## Aim of the publication

## What you need to reproduce the script
- All necessary files 
- R, Rstudio and the packages. Renv is used with this project. See .Rprofile for used packages
- Maybe you need to adjust the folder and the root dir (see setup chunk)  
- Install the necessary fonts (see setup chunk)

## About the authors

## About Reinickendorf

# Setup

## Setting options for knitr, ggplot, fonts 
```{r setup output options}
# Disabeling scientific notation
options(scipen = 999)

# Adjust the root directory. Depending on the placement of your R-Project-File you need to adjust this 
# knitr::opts_knit$set(root.dir = here::here())

# Create correct figure caption
knitr::opts_knit$set(eval.after = 'fig.cap')

# Adjust the big mark for large numbers
knitr::knit_hooks$set(inline = function(x) { prettyNum(x, big.mark=" ") })

# Setting the ggplot theme
ester_theme <- function() {
  theme(
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(family = "PT-Regular"),
    legend.position = "bottom",
    legend.direction = "horizontal"
  )
}

# Create colour palette for ggplot
mypalette = 'Set1'

# Fonts
# Setup: You will only need to run this once, but it will take a few minutes to finish 
# Install https://fonts.google.com/specimen/PT+Sans on your local computer
# install.packages("extrafont")
# library(extrafont)
# font_import() # Import all the .ttf files from your system. On Linux see also: https://stackoverflow.com/questions/61204259/how-can-i-resolve-the-no-font-name-issue-when-importing-fonts-into-r-using-ext

```

## Creating storage variables
```{r creating storage variables}
# This variable stores all numbers needed for the method section in the script
methodslist <- list()
resultslist <- list()

# Create a check function for testing purposes
checkanonids <- function(){
# df %>% count(AnonID) %>% filter(n>3) %>% pull(AnonID)
print(df %>% filter(AnonID=="ID021580"))
print(df %>% filter(AnonID == "ID037188"))
print(df %>% filter(AnonID == "ID015472"))
}
```

## External input
```{r Methods external input}
source("code/external_input.R")
```


## Population data from Berlin Reinickendorf, Germany
```{r population data}
read_demographiedata <- function(datafile = "data/EWR202012E_Matrix.csv"){
    datafile %>% 
  read_delim(delim = ";", show_col_types = FALSE) %>% 
  filter(BEZ == "12")  %>% 
  summarise('0 to 6' = sum(E_E00_01 + E_E01_02  + E_E02_03  + E_E03_05  + E_E05_06  +E_E06_07),
            '7 to 17' = sum(E_E07_08 + E_E08_10  + E_E10_12 + E_E12_14 + E_E14_15  + E_E15_18),
            '18 to 64' = sum(E_E18U25 + E_E25U55 + E_E55U65),
            '65 to 110' = sum(E_E65U80 + E_E80U110)) %>% 
  pivot_longer(cols = everything())
}

demographiedata <- read_demographiedata()
```


## Reading and tidying the dataset
```{r reading and tidying, eval = params$completerun}

read_survnetdata <- function(datafile ="data/absonderungslast_ohneNamen_altersgruppe2.csv"){
  datafile %>% 
  read_delim(delim = ",", show_col_types = FALSE)  %>%  # reading in the date
  rowid_to_column() %>% # Add RowID (this is needed for the purr::map function)
  rename(AbsonderungBis = AbsonderunBis) %>% # Correct SurvNet mistake
  mutate(Meldedatum = as.Date(Meldedatum, format = "%d.%m.%Y")) %>% 
  mutate(AbsonderungVon = as.Date(AbsonderungVon, format = "%d.%m.%Y")) %>% 
  mutate(AbsonderungBis = as.Date(AbsonderungBis, format = "%d.%m.%Y")) %>% 
  mutate(Meldemonat = paste(year(AbsonderungVon), format.Date(AbsonderungVon, "%m"), sep = "_")) %>% 
  mutate(Meldewoche = paste(year(AbsonderungVon), format.Date(AbsonderungVon, "%W"), sep = "_")) %>% 
  mutate(dauer = as.numeric(AbsonderungBis - AbsonderungVon)) %>% 
  mutate(abstandVonBis = AbsonderungBis - AbsonderungVon) %>% # create time periods used for filtering
  mutate(abstandMeldedatumVon = Meldedatum - AbsonderungVon) %>% # create time periods used for filtering
  mutate(AgeGroup = recode_factor(AgeGroup, "<7" = "0 to 6", "7bis17" = "7 to 17", "18bis64" = "18 to 64", ">64" = "65 to 110", .ordered = TRUE))
}

df <- read_survnetdata()

```


##  Filtering
```{r Filtering, eval = params$completerun}
# Saving for publication
methodslist$queried <- nrow(df)

# finding entries that meet the case definition
df <- df %>% 
  mutate(definitionvar = "notdefined") %>% 
  mutate(definitionvar = ifelse(!is.na(AbsonderungVon) & !is.na(AbsonderungBis), "defined", definitionvar)) %>% 
  mutate(definitionvar = ifelse(!is.na(AbsonderungVon) & !is.na(AbsonderungBis), "defined", definitionvar)) %>% 
  mutate(definitionvar = ifelse(AnonID == externalinput$wrong_id, "wrongID", definitionvar)) %>% 
  mutate(definitionvar = ifelse(AnonID == externalinput$wrong_id2, "wrongID", definitionvar)) 
# saving for results
methodslist$definitionvar <- table(df$definitionvar)
# actual filtering
df <- df %>% filter(definitionvar == "defined")

# finding entries whith a date that is not in the timeframe
df <- df %>% 
  mutate(outofrange = "inrange") %>% 
  mutate(outofrange = ifelse(AbsonderungVon < externalinput$StartDate | AbsonderungVon > (externalinput$EndDate + 14), "outofrange", outofrange)) %>%
  mutate(outofrange = ifelse(AbsonderungBis < externalinput$StartDate | AbsonderungBis > (externalinput$EndDate + 14), "outofrange", outofrange)) %>%
  mutate(outofrange = ifelse(Meldedatum < externalinput$StartDate | Meldedatum > (externalinput$EndDate + 14), "outofrange", outofrange)) 
# saving for results
methodslist$outofrange <- table(df$outofrange)
# actual filtering
df <- df %>% filter(outofrange == "inrange")

# finding entries with a presumable data entry error
df <- df  %>% 
  mutate(filtervar = "korrekt") %>% 
  mutate(filtervar = ifelse(abstandVonBis > 30, "typingerror", filtervar)) %>%
  mutate(filtervar = ifelse(abstandVonBis < 1, "typingerror", filtervar)) %>%
  mutate(filtervar = ifelse(abstandMeldedatumVon < -30, "typingerror", filtervar)) %>%
  mutate(filtervar = ifelse(abstandMeldedatumVon > 30, "typingerror", filtervar)) 
# saving for results
methodslist$wrongEntries <- table(df$filtervar) 
# actual filtering
df <- df %>%  filter(filtervar == "korrekt") 

# cleaning up  
df <- df %>% select(-abstandMeldedatumVon, -abstandVonBis, -filtervar, -outofrange, -definitionvar)
```

## Filtering and adjusting duplicate entries
This part looks for duplicated separation orders. It takes the maximum and the minimum of duplicated entries 
```{r Duplicate entries, eval = params$completerun}
# This function creates a list of numbers which is needed for the other functions
overlapcheck_pairs <- function(highest = 10){
  mytibble <- tibble(value = 1:highest) %>% 
    expand(value, value1 = value) %>% 
    filter(value < value1) 
  mylist <- map(1:nrow(mytibble), ~c(mytibble$value[.x], mytibble$value1[.x]))
  mylist
}
# This call creates the list with the function overlapcheck_pairs
pairslist <- map(1:(df %>% count(AnonID) %>% top_n(1, wt = n) %>% pull(n))[1], ~overlapcheck_pairs(.x)) # Legt die Pairsliste an

# This function checks wheter two entries overlap
overlapcheck <- function(data_input, pair) {
  i <- pair[1]
  j <- pair[2]
  first <- c(data_input$AbsonderungVon[i], data_input$AbsonderungBis[i])
  second <- c(data_input$AbsonderungVon[j], data_input$AbsonderungBis[j])
if(first %overlaps% second) {
  data_input$AbsonderungVon[i] <- min(c(first, second))
  data_input$AbsonderungBis[i] <- max(c(first, second))
  data_input <- data_input[-c(j),]
}
  data_input
}

# This function uses the function overlapcheck on the table of one person and gives the result with only correct entries. 
overlapcheck_concise <- function(data_input, testsubject) {
  tdf <- data_input %>% filter(AnonID == testsubject) 
  mylist <- pairslist[[nrow(tdf)]]
  allvalues <- map(mylist, ~overlapcheck(tdf, .x))
  table <- bind_rows(allvalues) 
  table %>% 
    count(rowid) %>% 
    filter(n==length(mylist)) %>% 
    select(-n) %>%  
    left_join(table, by = "rowid") %>% 
    distinct() %>% 
    group_by(rowid) %>% 
    mutate(AbsonderungVon = min(AbsonderungVon)) %>% 
    mutate(AbsonderungBis = max(AbsonderungBis)) %>% 
    distinct()
}

# To save calculation time the complete dataset is split up. I am sure there is an easier way but this is a safe way.
kps <- df %>% filter(DatensatzKategorie == "Kontakt-COVID-19")
faelle <- df %>% filter(DatensatzKategorie == "COVID-19")
einzelne_kps <- kps %>% count(AnonID) %>% filter(n==1) %>% pull(AnonID)
doppelte_kps <- kps %>% count(AnonID) %>% filter(n>1) %>% pull(AnonID)
einzelne_faelle <- faelle %>% count(AnonID) %>% filter(n==1) %>% pull(AnonID)
doppelte_faelle <- faelle %>% count(AnonID) %>% filter(n>1) %>% pull(AnonID)
einzelne_kps_df <- kps %>% filter(AnonID %in% einzelne_kps)
doppelte_kps_df <- kps %>% filter(AnonID %in% doppelte_kps)
einzelne_faelle_df <- faelle %>% filter(AnonID %in% einzelne_faelle)
doppelte_faelle_df <- faelle %>% filter(AnonID %in% doppelte_faelle)

# These functions do the actual work of adjusting the overlapping periods
doppelte_faelle_df_bereinigt <- bind_rows(map(doppelte_faelle, ~overlapcheck_concise(data_input = doppelte_faelle_df, testsubject = .x)))
doppelte_kps_df_bereinigt <- bind_rows(map(doppelte_kps, ~overlapcheck_concise(data_input = doppelte_kps_df, testsubject = .x)))

# Saving for the publication
methodslist$doppeltefaelle <- nrow(doppelte_faelle_df) - nrow(doppelte_faelle_df_bereinigt)
methodslist$doppeltekps <- nrow(doppelte_kps_df) - nrow(doppelte_kps_df_bereinigt)

# Putting the table back together
df <- bind_rows(doppelte_faelle_df_bereinigt, doppelte_kps_df_bereinigt, einzelne_faelle_df, einzelne_kps_df) %>% ungroup()
```


## Correct quarantine if it overlaps with isolation
This functions checks for overlapping quarantine and isolation orders. 

> The following variantes are possible
> 1 
> KP   |----|
> Case |----|
> Filter min(kp)>=min(case)
> result should be:  delete(KP)
> 2
> KP      |----|
> Case |----|
> Filter min(kp)>=min(case)
> result should be: delete(kp)
> 4
> KP    |--|
> Case |----|
> Filter min(kp)>=min(case)
> result should be:  delete(KP) 
> 6
> KP   |--|
> Case |----|
> Filter min(kp)>=min(case)
> result should be: delete(KP)
> KP   |----|
> Case |--|
> Filter min(kp)>=min(case) 
> result should be: delete(kp)
> 8
> KP    |---|
> Case |----|
> Filter min(kp)>=min(case)
> result should be: delete(kp)
> 3
> KP   |----|
> Case    |----|
> Filter min(kp)<min(case)
> result should be:  min(KP) - min(Case)
> 5
> KP   |----|
> Case  |--|
> Filter min(kp)<min(case)
> result should be: min(KP) - min(case)
> 9
> KP   |----|
> Case  |---|
> Filter min(kp)<min(case)
> result should be: min(kp) - min(case)

For examples check the following AnonIDs: ID000004, ID000002, ID000435

```{r quarantine-isolation-overlap, eval = params$completerun}
# overlappingQandI_df <- tibble(AnonID = unique(df$AnonID), overlappingIDs = rep(NA, length(unique(df$AnonID))))

# This function checks for overlap and adjusts the quarantine if needed
adjustoverlapquarantine <- function(data_input, pair) {
  i <- pair[1]
  j <- pair[2]
  first <- c(data_input$AbsonderungVon[i], data_input$AbsonderungBis[i])
  second <- c(data_input$AbsonderungVon[j], data_input$AbsonderungBis[j])
  firstsequence <- seq(data_input$AbsonderungVon[i], data_input$AbsonderungBis[i], by = 1)
  secondsequence <- seq(data_input$AbsonderungVon[j], data_input$AbsonderungBis[j], by = 1)
  if(first %overlaps% second) {
    if(data_input$DatensatzKategorie[i] == "COVID-19" & data_input$DatensatzKategorie[j] == "Kontakt-COVID-19") {
      if(min(secondsequence)<min(firstsequence)){
        data_input$AbsonderungVon[j] <- min(secondsequence)
        data_input$AbsonderungBis[j] <- min(firstsequence)  
      } else {data_input <- data_input[-c(j),]}
      
    }  else if(data_input$DatensatzKategorie[i] == "Kontakt-COVID-19" & data_input$DatensatzKategorie[j] == "COVID-19") {
      if(min(firstsequence)<min(secondsequence)){
        data_input$AbsonderungVon[i] <- min(firstsequence)
        data_input$AbsonderungBis[i] <- min(secondsequence)  
      } else {data_input <- data_input[-c(i),]}
    }
  }
  data_input
}

# This function applies the adjustoverlapquarantine to every testsubject
adjustoverlapquarantine_concise <- function(data_input, testsubject) {
  tdf <- data_input %>% filter(AnonID == testsubject) 
  mylist <- pairslist[[nrow(tdf)]]
  allvalues <- map(mylist, ~adjustoverlapquarantine(tdf, .x))
  table <- bind_rows(allvalues) 
  table <- table %>% 
    count(rowid) %>% 
    filter(n==length(mylist)) %>% 
    select(-n) %>%  
    left_join(table, by = "rowid") %>% 
    distinct() %>% 
    group_by(rowid) %>% 
    mutate(AbsonderungVon = min(AbsonderungVon)) %>% 
    mutate(AbsonderungBis = min(AbsonderungBis)) %>% 
    distinct()
  
  table 
}


# Table is split up to save calculation time
einzelne_anonIDs <- df %>% count(AnonID) %>% filter(n==1) %>% pull(AnonID)
doppelte_anonIDs <- df %>% count(AnonID) %>% filter(n>1) %>% pull(AnonID)

einzelne_anonIDs_df <- df %>% filter(AnonID %in% einzelne_anonIDs)
doppelte_anonIDs_df <- df %>% filter(AnonID %in% doppelte_anonIDs)

# This function actually does all the work and puts together the functions above
doppelte_anonIDs_df_bereinigt <- bind_rows(map(doppelte_anonIDs, ~adjustoverlapquarantine_concise(data_input = doppelte_anonIDs_df, testsubject = .x)))

# Saving for the results
methodslist$ueberlappendeFalleKP <- nrow(doppelte_anonIDs_df) - nrow(doppelte_anonIDs_df_bereinigt) 
 
# The table is put together again
df <- bind_rows(doppelte_anonIDs_df_bereinigt, einzelne_anonIDs_df) %>% ungroup()
```


## Find adjoining quarantines and isolations 
```{r quarantine-isolation-adjoining, eval = params$completerun}

# Set empty value
df$adjoiningQandI <- NA

# what counts as adjoining 
adjoiningwhentimedifference <- seq(0,6) 

adjoincheck <- function(data_input, pair) {
  i <- pair[1] # this is number one
  j <- pair[2] # this is number two
  twoafterone <- data_input$AbsonderungVon[j] - data_input$AbsonderungBis[i]  # if one after two its positive
  oneaftertwo <- data_input$AbsonderungVon[i] - data_input$AbsonderungBis[j] # if two after one its positive
  if(data_input$DatensatzKategorie[i] == "COVID-19" & data_input$DatensatzKategorie[j] == "Kontakt-COVID-19") {
    if(oneaftertwo %in% adjoiningwhentimedifference){
      data_input$adjoiningQandI[i] <- oneaftertwo
      data_input$adjoiningQandI[j] <- oneaftertwo
    } 
  }  else if(data_input$DatensatzKategorie[i] == "Kontakt-COVID-19" & data_input$DatensatzKategorie[j] == "COVID-19") {
    if(twoafterone %in% adjoiningwhentimedifference){
      data_input$adjoiningQandI[i] <- twoafterone
      data_input$adjoiningQandI[j] <- twoafterone
    }  
  }
  data_input
}
 
adjoincheck_concise <- function(data_input, testsubject) {
  tdf <- data_input %>% filter(AnonID == testsubject) 
  mylist <- pairslist[[nrow(tdf)]]
  allvalues <- map(mylist, ~adjoincheck(tdf, .x))
  table <- bind_rows(allvalues) 
  changedrowids <- table %>% filter(!is.na(adjoiningQandI)) %>% distinct()
  notchangedrowids <- table %>% filter(!rowid %in% changedrowids$rowid) %>% select(rowid) %>% distinct() %>% left_join(tdf, by = "rowid")
  data_output <- bind_rows(changedrowids, notchangedrowids)
  data_output
}

# Split up the df to save computing time
einzelne_anonIDs <- df %>% count(AnonID) %>% filter(n==1) %>% pull(AnonID)
doppelte_anonIDs <- df %>% count(AnonID) %>% filter(n>1) %>% pull(AnonID)
einzelne_anonIDs_df <- df %>% filter(AnonID %in% einzelne_anonIDs)
doppelte_anonIDs_df <- df %>% filter(AnonID %in% doppelte_anonIDs)

# This call does all the work 
doppelte_anonIDs_df_bereinigt <- bind_rows(map(doppelte_anonIDs, ~adjoincheck_concise(data_input = doppelte_anonIDs_df, testsubject = .x)))

# The df is put together again
df <- bind_rows(doppelte_anonIDs_df_bereinigt, einzelne_anonIDs_df)

```


## Time periods
```{r timeperiods, eval = params$completerun}

# Join with the main dataset
df <- df %>% 
  left_join(externalinput$zeiten, by = c("AbsonderungVon" = "dates"))
```


```{r}
# df %>% 
#   filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
#   mutate(Q_Duration_number = str_split(Q_Duration_shortvalue, " ", simplify = TRUE)[1]) %>% 
#   mutate(Q_Duration_number = as.numeric(Q_Duration_number)) %>% 
#   filter(Q_Duration_number == 14) %>% 
#   mutate(Q_timeliness = dauer - Q_Duration_number) %>% 
#   group_by(Meldewoche) %>% 
#   summarise(timeliniess = mean(Q_timeliness)) %>% 
#   ggplot(aes(Meldewoche, timeliniess)) +
#   ester_theme() +
#   geom_col()
```



## Save datasets
```{r saving_datasets, eval = params$completerun}
saveRDS(df, paste0("data/", today(), "-df.rdata"))
saveRDS(methodslist, paste0("data/", today(), "-methodslist.rdata"))
saveRDS(resultslist, paste0("data/", today(), "-resultslist.rdata"))
saveRDS(demographiedaten, paste0("data/", today(), "-demographiedaten.rdata"))
saveRDS(zeiten, paste0("data/", today(), "-zeiten.rdata"))

# rm(list=ls())
```



# Results
```{r Results}
# Hier wird die gespeicherte Tabelle eingelesen
df <- readRDS(paste0("data/", params$dataversion, "-df.rdata")) %>% ungroup()
methodslist <- readRDS(paste0("data/", params$dataversion, "-methodslist.rdata"))
resultslist <- readRDS(paste0("data/", params$dataversion, "-resultslist.rdata"))
demographiedaten <- readRDS(paste0("data/", params$dataversion, "-demographiedaten.rdata"))
zeiten <- readRDS(paste0("data/", params$dataversion, "-zeiten.rdata"))
```

## Numbers of quarantine and isolation
```{r N_and_incidence}
# N quarantines
resultslist$AnzahlQAgegroup <- df %>% filter(DatensatzKategorie == "Kontakt-COVID-19") %>% group_by(AgeGroup) %>% summarise(n = n()) %>% pull(n)
resultslist$GesamtQ <- sum(resultslist$AnzahlQAgegroup) 

# N isolations
resultslist$AnzahlIAgegroup <- df %>% filter(DatensatzKategorie == "COVID-19") %>%  group_by(AgeGroup) %>% summarise(n = n()) %>% pull(n)
resultslist$GesamtI <- sum(resultslist$AnzahlIAgegroup )

# Quarantines by population
resultslist$AnzahlQproBev <- round(100*resultslist$GesamtQ / demographiedaten %>% summarise(sum(value)) %>% pull(), 1)
resultslist$AnzahlQproBevAgegroup <- round(100 * resultslist$AnzahlQAgegroup  / demographiedaten$value, 1)

# Isolations by population
resultslist$AnzahlIproBev <- round(100*resultslist$GesamtI / demographiedaten %>% summarise(sum(value)) %>% pull(),1)
resultslist$AnzahlIproBevAgegroup <- round(100 * resultslist$AnzahlIAgegroup  / demographiedaten$value, 1)

resultslist$incidence <- df %>% 
  group_by(AgeGroup, DatensatzKategorie) %>% 
  summarise(n = n(), .groups = 'drop') %>% 
  left_join(demographiedaten, by= c("AgeGroup" = "name") ) %>% 
  rename(N = value) %>% 
  mutate(incidence = round(100*n/N)) %>% 
  mutate(DatensatzKategorie = recode_factor(DatensatzKategorie, "COVID-19" = "isolation", "Kontakt-COVID-19" = "quarantine"))

resultslist$incidence_total <- df %>% 
    group_by(DatensatzKategorie) %>% 
    summarise(n = n(), .groups = 'drop') %>% 
    mutate(totalpopulation = demographiedaten %>% summarise(sum(value))) %>% 
    mutate(incidence = round(100*n/totalpopulation)) 


```

The local public health agency Reinickendorf ordered isolations for slightly less than 10\% and quarantines for a bit more than 15\% of the population. This amounts to XXX days per person. The local public health agency of Reinickendorf ordered roughly 1700 years of quarantine in total.



## Calculate time periods
```{r calculate_time_periods}
# Total duration of quarantine and isolation
resultslist$NQundI <- df %>% summarise(sum(dauer)) %>% pull()

# Quarantine duration
resultslist$MedianeDauerQ <- df %>% filter(DatensatzKategorie == "Kontakt-COVID-19") %>% summarise(quint = quantile(dauer)) %>% pull()
resultslist$MedianeDauerQ_Rec <- df %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(Q_Duration) %>% 
  summarise(quint = quantile(dauer, probs = 0.5 ), .groups = 'drop') 

# Isolation duration
resultslist$MedianeDauerI <- df %>% filter(DatensatzKategorie == "COVID-19") %>% summarise(quint = quantile(dauer)) %>% pull()
resultslist$MedianeDauerI_Rec <- df %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  group_by(I_Duration) %>% 
  summarise(quint = quantile(dauer, probs = 0.5 ), .groups = 'drop') 

resultslist$MedianeDauerAbsonderungAgeGroup <- df %>% group_by(DatensatzKategorie, AgeGroup) %>% summarise(quint = quantile(dauer), .groups = 'drop')


# total time
resultslist$totaltime_groups <- df %>% 
  group_by(DatensatzKategorie, AgeGroup) %>% 
  summarise(completeduration_days = sum(dauer), completeduration_years = sum(dauer) / 365, .groups = "drop_last") %>% 
  left_join(demographiedaten, by = c("AgeGroup" = "name")) %>% 
  mutate(percentage = round(100 * completeduration_days / sum(completeduration_days),1)) %>% 
  mutate(completeduration_person = round(completeduration_days / value,1)) %>% 
  ungroup()

resultslist$totaltime <- resultslist$totaltime_groups %>% group_by(DatensatzKategorie) %>% summarise(completeduration_total = round(sum(completeduration_years),1))

# print(resultslist$totaltime)
```

## Calculate ratio of quarantines to isolations
```{r quarantines_isolation_ratio}
resultslist$K_F_Verhaeltnis <- df %>%
  filter(AbsonderungVon > externalinput$StartDateKP) %>% 
  filter(AbsonderungVon < externalinput$EndDateKP) %>% 
  group_by(DatensatzKategorie) %>%
  summarise(n=n(), .groups = "drop") %>% 
  pivot_wider(names_from = DatensatzKategorie, values_from = n) %>% 
  janitor::clean_names() %>% 
  mutate(verhaeltnis = round(kontakt_covid_19 / covid_19,2)) %>% 
  pull(verhaeltnis)
  
resultslist$K_F_Verhaeltnis_QDef <- df %>%
  filter(AbsonderungVon > externalinput$StartDateKP) %>% 
  filter(AbsonderungVon < externalinput$EndDateKP) %>% 
  group_by(Q_Def, DatensatzKategorie) %>%
  summarise(n=n(), .groups = "drop") %>% 
  pivot_wider(names_from = DatensatzKategorie, values_from = n) %>% 
  janitor::clean_names() %>% 
  mutate(verhaeltnis = round(kontakt_covid_19 / covid_19,2))
```

## Quarantines and isolation per person
```{r quarantines_isolation_per_person}
resultslist$QundIproPerson <- df %>% 
  group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  count(number = n) %>% 
  mutate(Percentage= round( n / sum(n) * 100, 1)) 
  
resultslist$highestQundIproPerson <- df %>% group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  count(number = n) %>% 
  slice_max(number) %>% 
  pull(number)
```

## Find quarantines and isolations that adjoin
```{r adjoining_quarantines_and_isolation}
resultslist$ueberlappendeQundI <- df %>%
  filter(AbsonderungVon > externalinput$StartDateKP & AbsonderungVon < externalinput$EndDateKP) %>% 
  group_by(DatensatzKategorie, adjoiningQandI, AgeGroup, Q_Def) %>%
  count() %>% 
  mutate(result = NA) %>% 
  mutate(result = ifelse(adjoiningQandI == 0, "I_correct_after_Q", result)) %>% 
  mutate(result = ifelse(adjoiningQandI > 0, "I_too_long_after_Q", result)) %>% 
  mutate(result = ifelse(is.na(adjoiningQandI), "No_I_after_Q", result)) 

resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(Q_Def, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100)

resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(AgeGroup, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100)
```

## Text for Publication 
We extracted `r methodslist$queried` datasets from SurvNet. `r methodslist$outofrange[['inrange']]` entries fullfilled the definition `r methodslist$definitionvar[['notdefined']]` had missing dates, `r methodslist$definitionvar[['wrongID']]` entries had an IDs that did not lead to an existing person and `r methodslist$outofrange[['outofrange']]` did not have a beginning of the stay-at-home-order in the study period). We removed `r methodslist$wrongEntries[['typingerror']]` entries because they had a presumed typing error in one of the dates. We also removed `r methodslist$doppeltefaelle ` duplicated isolations and `r methodslist$doppeltekps ` duplicated quarantines. For XXXX quarantines we reduced the length by the overlap with a following isolation period. In the demographic data we found `r demographiedaten %>% summarise(sum(value)) %>% pull() ` inhabitants registered in Berlin Reinickendorf (`r demographiedaten %>% filter(name=="Kleiner7") %>% pull(value) ` in the age group <7; `r demographiedaten %>% filter(name=="Von7Bis17") %>% pull(value) ` in the age group 7-17; `r demographiedaten %>% filter(name=="Von18bis65") %>% pull(value) ` in the age group 18-64 and `r demographiedaten %>% filter(name=="Groesser64") %>% pull(value) ` in the age group >64).

*Analysis of quantity of isolation and quarantines:*  The local public health institute Reinickendorf von  Berlin did order `r resultslist$GesamtI ` isolations and `r resultslist$GesamtQ` quarantines. This amounts to a percentage of `r round(resultslist$GesamtI * 100 / demographiedaten %>% summarise(sum(value)),1) %>% pull()` isolations and `r round(resultslist$GesamtQ * 100 / demographiedaten %>% summarise(sum(value)) %>% pull(),1) ` quarantines of inhabitants. The number of isolations per 100 people in each age group was:  `r resultslist$incidence %>% filter(DatensatzKategorie == "isolation" & AgeGroup == "< 7") %>% pull(incidence) %>% round()` <7, `r resultslist$incidence %>% filter(DatensatzKategorie == "isolation" & AgeGroup == "7 to 17") %>% pull(incidence) %>% round()` 7-17, `r resultslist$incidence %>% filter(DatensatzKategorie == "isolation" & AgeGroup == "18 to 64") %>% pull(incidence) %>% round()` 18-64, `r resultslist$incidence %>% filter(DatensatzKategorie == "isolation" & AgeGroup == " > 64") %>% pull(incidence) %>% round()` >64. The number of quarantines per 100 people in each age group was:  `r resultslist$incidence %>% filter(DatensatzKategorie == "quarantine" & AgeGroup == "< 7") %>% pull(incidence) %>% round()` in the age group <7, `r resultslist$incidence %>% filter(DatensatzKategorie == "quarantine" & AgeGroup == "7 to 17") %>% pull(incidence) %>% round()` in the age group 7-17, `r resultslist$incidence %>% filter(DatensatzKategorie == "quarantine" & AgeGroup == "18 to 64") %>% pull(incidence) %>% round()` in the age group 18-64, `r resultslist$incidence %>% filter(DatensatzKategorie == "quarantine" & AgeGroup == " > 64") %>% pull(incidence) %>% round()` in the age group >64 (see figure \@ref(fig:incidence)). `r resultslist$QundIproPerson %>% filter(number==1) %>% pull(Percentage)` % of persons had one stay at home order (quarantine or isolation), `r resultslist$QundIproPerson %>% filter(number==2) %>% pull(Percentage)` % had two stay at home orders and `r resultslist$QundIproPerson %>% filter(number==3) %>% pull(Percentage)` % had three stay at home orders. The maximum number of stay at home orders per person was `r resultslist$highestQundIproPerson`.  

*Analysis of the duration of isolation quarantines:* The median duration for isolations was `r resultslist$MedianeDauerI["50%"] ` (interquartile range `r resultslist$MedianeDauerI["25%"]` - `r resultslist$MedianeDauerI["75%"] `). The duration did change in between different periods of recommendations. The median of the duration during the recommendation periods were: `r resultslist$MedianeDauerI_Rec %>% filter(I_Duration == "I_Duration_1") %>% select(quint) %>% pull()` for the period No. 1, `r resultslist$MedianeDauerI_Rec %>% filter(I_Duration == "I_Duration_2") %>% select(quint) %>% pull()` for the period No. 2, `r resultslist$MedianeDauerI_Rec %>% filter(I_Duration == "I_Duration_3") %>% select(quint) %>% pull()` for the period No. 3 and `r resultslist$MedianeDauerI_Rec %>% filter(I_Duration == "I_Duration_4") %>% select(quint) %>% pull()` for the period No. 4. The overall median duration for quarantines was `r resultslist$MedianeDauerQ["50%"] ` (interquartile range `r resultslist$MedianeDauerQ["25%"]` - `r resultslist$MedianeDauerQ["75%"] `). The median duration did differ between periods of different recommendations and age groups. The median of the duration during the recommendation periods were: `r resultslist$MedianeDauerQ_Rec %>% filter(Q_Duration == "Q_Duration_1") %>% select(quint) %>% pull()` for the period No. 1, `r resultslist$MedianeDauerQ_Rec %>% filter(Q_Duration == "Q_Duration_2") %>% select(quint) %>% pull()` for the period No. 2, `r resultslist$MedianeDauerQ_Rec %>% filter(Q_Duration == "Q_Duration_3") %>% select(quint) %>% pull()` for the period No. 3 and `r resultslist$MedianeDauerQ_Rec %>% filter(Q_Duration == "Q_Duration_4") %>% select(quint) %>% pull()` for the period No. 4. See figure \@ref(fig:duration). All together the public health agency ordered `r resultslist$totaltime %>% filter(DatensatzKategorie == "COVID-19") %>% pull(completeduration_total)` years of isolations and `r resultslist$totaltime %>% filter(DatensatzKategorie == "Kontakt-COVID-19") %>% pull(completeduration_total)` years of quarantine. 

*Analysis of the ratio of contact persons per case:* The overal ratio of contact persons was `r round(resultslist$K_F_Verhaeltnis,2)`. In the period of the contact person defintion no. 1 the ratio was `r resultslist$K_F_Verhaeltnis_QDef %>% filter(q_def == "Q_Def_1") %>% pull(verhaeltnis) ` in the period no. 2 the ratio was `r resultslist$K_F_Verhaeltnis_QDef %>% filter(q_def == "Q_Def_2") %>% pull(verhaeltnis)` and in the period no. 3 the ratio was: `r resultslist$K_F_Verhaeltnis_QDef %>% filter(q_def == "Q_Def_1") %>% pull(verhaeltnis)`. 

*Analysis of isolations following quarantines:* All together `r resultslist$Q_percentage` of quarantines had a following isolation. And `r  resultslist$I_percentage` isolations had a preceeding quarantine. This did differ between different periods and recommendations see figure \@ref(fig:adjoining-quarantines-and-isolation). A total of `r resultslist$isolationduringcontact` quarantines had a following isolation period. With the overall ratio of cases to contacts of `r resultslist$K_F_Verhaeltnis` and assuming of a total prevention of transmission this leads to `r round(resultslist$K_F_Verhaeltnis * resultslist$isolationduringcontact)` directly prevented/delayed cases.


# Tables
```{r totaltime_groups, echo = FALSE}
set.caption('Total duration of SARS-CoV-2 quarantines and isolations per age and the percentage of each age group from the total.') 
resultslist$totaltime_groups %>% 
    mutate(AgeGroup = recode_factor(AgeGroup,  "Kleiner7" = "< 7", "Von7Bis17" = "7 to 17", "Von18bis65" = "18 to 64", "Groesser64" = " > 64")) %>% 
  mutate(Type = recode_factor(DatensatzKategorie, "COVID-19" = "isolation", "Kontakt-COVID-19" = "quarantine")) %>% 
  select(Type, 'Age group' = AgeGroup, 'duration (d)' = completeduration_days, 'duration per person' = completeduration_person, 'Share in %' = percentage) %>% 
  pander()
```

# Graphs

## Graph: Incidence 
```{r incidence, fig.height= 3, fig.cap=paste("Incidence per 1000 of quarantines and isolations for inhabitants of Reinickendorf, Berlin between",  externalinput$StartDate, "and", externalinput$EndDate), error=FALSE, message=FALSE, warning=FALSE}
p1 <- resultslist$incidence %>% 
   mutate(AgeGroup = recode_factor(AgeGroup, "0 to 6" = "0 to 6", "7 to 17" = "7 to 17", "18 to 64" = "18 to 64", "65 to 110" = "65 to 110", .ordered = TRUE)) %>% 
  filter(DatensatzKategorie == "isolation") %>% 
  mutate(labelvalue = paste(incidence, "%")) %>% 
  ggplot(aes(x=AgeGroup, y=incidence, fill=DatensatzKategorie)) + 
  ester_theme() +
  geom_col() +
  scale_fill_brewer(palette = mypalette) +
  geom_text(aes(label = labelvalue), nudge_y = 3) + 
  xlab("") +
  ylab("isolations per 100 inhabitants") +
  ggtitle("Isolations by age group") +
  theme(legend.position = "none") 

p2 <- resultslist$incidence %>% 
   mutate(AgeGroup = recode_factor(AgeGroup, "0 to 6" = "0 to 6", "7 to 17" = "7 to 17", "18 to 64" = "18 to 64", "65 to 110" = "65 to 110", .ordered = TRUE)) %>% 
  filter(DatensatzKategorie == "quarantine") %>% 
  mutate(labelvalue = paste(incidence, "%")) %>% 
  ggplot(aes(x=AgeGroup, y=incidence, fill=DatensatzKategorie)) + 
  ester_theme() +
  geom_col(fill = brewer.pal(3, mypalette)[2]) +
  # scale_fill_brewer(palette = mypalette[2]) +
  geom_text(aes(label = labelvalue), nudge_y = 3) + 
  xlab("") +
  ylab("quarantines per 100 inhabitants") +
  ggtitle("Quarantine by age group") +
  theme(legend.position = "none") 

p_gesamt <- grid.arrange(p1,p2)

ggsave("graph/incidence.eps", p_gesamt, width = 7, height = 7)
```




## Graph: Quarantine duration by age group
```{r duration, fig.cap="Figure quarantine duration per age group", error=FALSE, message=FALSE, warning=FALSE}

p1 <- df %>%
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  filter(!is.na(Q_Duration)) %>% 
  group_by(AgeGroup) %>% 
  ggplot(aes(factor(AgeGroup), as.numeric(dauer))) +
  ester_theme() +
  geom_boxplot(outlier.shape = NA, fill = brewer.pal(3, mypalette)[2]) +
  facet_grid(~Q_Duration) +
  coord_cartesian(ylim = c(0, 23)) +
  ylab("duration in days") +
  xlab("") +
  ggtitle("Duration of quarantine in Reinickendorf Berlin")  +
  theme(axis.text.x = element_text(angle=45, vjust = 1, hjust=1))



p2 <- df %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  filter(!is.na(Q_Duration)) %>% 
  group_by(AgeGroup) %>% 
  ggplot(aes(factor(AgeGroup), as.numeric(dauer))) +
  ester_theme() +
  geom_boxplot(outlier.shape = NA) +
  # geom_violin(scale = "count") +
  facet_grid(~I_Duration) +
  coord_cartesian(ylim = c(0,28)) +
  geom_boxplot(outlier.shape = NA, fill = brewer.pal(3, mypalette)[1]) +
  ylab("duration in days") +
  xlab("") +
  ggtitle("Duration of isolation in Reinickendorf Berlin") +
  theme(axis.text.x = element_text(angle=45, vjust = 1, hjust=1))

p_gesamt <- grid.arrange(p1,p2)

ggsave("graph/duration.eps", p_gesamt)

```


## Graph: Adjoining quarantines and isolation
```{r adjoining-quarantines-and-isolation, fig.cap="Percentage of quarantines with an adjoining isolation or vice versa by definition period", error=FALSE, message=FALSE, warning=FALSE}

p1 <- resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(Q_Def, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100) %>%
  ungroup() %>% 
  filter(result == "I_correct_after_Q" | result == "I_too_long_after_Q") %>% 
  mutate(Q_Def = recode_factor(Q_Def, "Q_Def_1" = "Def_1", "Q_Def_2" = "Def_2", "Q_Def_3" = "Def_3", .ordered = TRUE)) %>% 
  mutate(result = recode_factor(result, "I_too_long_after_Q" = "Isolation missed", "I_correct_after_Q" = "Isolation starts after quarantine", .ordered = TRUE)) %>% 
  ggplot(aes(x=Q_Def, y = percentage, fill = result)) +
  geom_col() +
  ester_theme() +
  scale_fill_brewer(palette=mypalette) +
  scale_y_continuous(limits = c(0,21)) +
  ylab("%") +
  xlab("Contact person definition period") +
  theme(legend.position = "none")

p2 <- resultslist$ueberlappendeQundI %>%
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(AgeGroup, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100) %>%
  ungroup() %>% 
  filter(result == "I_correct_after_Q" | result == "I_too_long_after_Q") %>% 
  mutate(result = recode_factor(result, "I_too_long_after_Q" = "Isolation missed", "I_correct_after_Q" = "Isolation starts after quarantine", .ordered = TRUE)) %>% 
  ggplot(aes(x=AgeGroup, y = percentage, fill = result)) +
  geom_col() +
  ester_theme() +
  scale_fill_brewer(palette=mypalette) +
  scale_y_continuous(limits = c(0,21)) +
  ylab("%") +
  xlab("Age group") +
  theme(legend.position = "none")

p3 <- resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  group_by(Q_Def, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100) %>%
  ungroup() %>% 
  filter(result == "I_correct_after_Q" | result == "I_too_long_after_Q") %>% 
  mutate(Q_Def = recode_factor(Q_Def, "Q_Def_1" = "Def_1", "Q_Def_2" = "Def_2", "Q_Def_3" = "Def_3", .ordered = TRUE)) %>% 
  mutate(result = recode_factor(result, "I_too_long_after_Q" = "Isolation missed", "I_correct_after_Q" = "Isolation starts after quarantine", .ordered = TRUE)) %>% 
  ggplot(aes(x=Q_Def, y = percentage, fill = result)) +
  geom_col() +
  ester_theme() +
  scale_y_continuous(limits = c(0,40)) +
  scale_fill_brewer(palette=mypalette) +
  ylab("%") +
  xlab("Contact person definition period") +
  theme(legend.position = "none")

p4 <- resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  group_by(AgeGroup, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100) %>%
  ungroup() %>% 
  filter(result == "I_correct_after_Q" | result == "I_too_long_after_Q") %>% 
  mutate(result = recode_factor(result, "I_too_long_after_Q" = "Isolation missed", "I_correct_after_Q" = "Isolation starts after quarantine", .ordered = TRUE)) %>% 
  ggplot(aes(x=AgeGroup, y = percentage, fill = result)) +
  geom_col() +
  ester_theme() +
  scale_fill_brewer(palette=mypalette) +
  scale_y_continuous(limits = c(0,40)) +
  ylab("%") +
  xlab("Age group") +
  theme(legend.position = "none")

p_gesamt_1 <- grid.arrange(p1,p2, 
                           top = grid::textGrob("Percentage of quarantines that were followed by an isolation period", gp = grid::gpar(fontsize=14)), 
                           ncol = 2)
p_gesamt_2 <- grid.arrange(p3,p4,  
                           top = grid::textGrob("Percentage of isolations that were preceeded by a quarantine period", gp = grid::gpar(fontsize=14)), 
                           ncol = 2)
p_gesamt <- grid.arrange(p_gesamt_1, p_gesamt_2)


ggsave("graph/adjoining.eps", p_gesamt, width = 7, height = 7)

```


## Graph: Quarantines and isolation over time
```{r Quarantines-and-isolation-over-time, fig.cap="Quarantines and isolation over time", error=FALSE, message=FALSE, warning=FALSE}
df %>% 
  mutate(meldezeit = floor_date(AbsonderungVon, "week")) %>% 
  ggplot(aes(meldezeit, fill = DatensatzKategorie)) + 
  ester_theme() +
  geom_bar() +
  scale_fill_brewer(palette=mypalette) +
  ylab("n") +
  xlab("") +
  ggtitle("Number of quarantines and isolations") +
  theme(legend.position = "none")

ggsave("graph/numberovertime.eps", width = 7, height = 7)

```

# Addendum

## Text: Check number of countries with contact tracing
```{r number_of_countries_with_contact_tracing}
# Data from https://www.bsg.ox.ac.uk/research/research-projects/covid-19-government-response-tracker
# We claim that 
oxcgrt <- read_csv("data/OxCGRT_latest.csv")

numberofcountrieswithcontacttracing <- oxcgrt %>% 
  select(contacttracing = 'H3_Contact tracing', CountryName) %>% 
  filter(contacttracing>0) %>%
  select(CountryName) %>% 
  distinct() %>% 
  nrow()
  
numberofcountries <- oxcgrt %>% 
  select(CountryName) %>% 
  distinct() %>% 
  nrow()
```

`r numberofcountrieswithcontacttracing` of `r numberofcountries` countries do contact tracing.



## Graph: Overview of separation orders by week
```{r overview_figure, fig.cap = "separation order duration by week"}
df2 <- df %>% 
  mutate(meldezeit = floor_date(AbsonderungVon, "week"))  %>% 
  group_by(meldezeit, DatensatzKategorie, AgeGroup) %>% 
  mutate(durationsum = sum(dauer)/365)

df2 %>% ggplot(aes(x = meldezeit, y = durationsum, fill = AgeGroup)) +
  ester_theme() +
 geom_col() +
facet_wrap(~DatensatzKategorie + AgeGroup, ncol = 4) +
    # geom_vline(xintercept = floor_date(ymd("2020_10_01"), unit = "week")) +
  ylab("Duration in years") 
```


## Graph: Ratio-of-contact-person-to-case
```{r Ratio-of-contact-person-to-case, fig.cap="Ratio of contact person to case by defintion of contact person"}
 resultslist$K_F_Verhaeltnis_QDef %>% 
  ggplot(aes(x = q_def, y = verhaeltnis)) + 
  ester_theme() +
  geom_bar(stat = "identity") +
  ylab("ratio contact persons to case") +
  xlab("") +
  ggtitle("Ratio of contact person to case by defintion of contact person") 
```

## Graph: Quarantines per isolation ratio per month
```{r KP-pro-Fall-pro-Monat, fig.cap="KP pro Fall pro Monat"}
df %>% 
  group_by(Meldemonat, DatensatzKategorie) %>% 
  count() %>% 
  pivot_wider(names_from = DatensatzKategorie, values_from = n) %>% 
  janitor::clean_names() %>% 
  mutate(verhaeltnis = kontakt_covid_19/covid_19) %>% 
  na.omit() %>% 
  ggplot(aes(x = meldemonat, y = verhaeltnis)) +
  ester_theme() +
  geom_bar(stat = "identity") 
```

## Graph: Duration over time
```{r graph-dauer-über-die-Zeit, fig.height = 15, fig.cap="Absonderungsdauern nach Meldemonat"}
ggplot(df, aes(as.numeric(dauer), fill = DatensatzKategorie)) +
  ester_theme() +
  geom_histogram(position = "dodge", bins = 30) +
  facet_wrap(~Q_Duration, scales = "free", ncol = 3) +
  scale_fill_brewer(palette=mypalette) +
  theme(legend.position = "bottom") +
  xlab("Absonderungsdauer") +
  ylab("Anzahl an Absonderungen")
```


## Graph: Overview over time periods
```{r zeiten, fig.cap="test"}
zeiten <- zeiten %>% 
  mutate(Q_Duration = str_extract(Q_Duration,"\\d+")) %>% 
  mutate(I_Duration = str_extract(I_Duration,"\\d+")) %>% 
  mutate(Q_Def = str_extract(Q_Def,"\\d+"))

graphtabelle <- bind_rows(
  zeiten %>% 
  group_by(Q_Duration) %>% 
  summarise(start = min(dates), end = max(dates)) %>% 
  mutate(group = "Q_Duration") %>% 
  rename(event = Q_Duration),
  zeiten %>% 
  group_by(I_Duration) %>% 
  summarise(start = min(dates), end = max(dates)) %>% 
  mutate(group = "I_Duration") %>% 
  rename(event = I_Duration),
  zeiten %>% 
  group_by(Q_Def) %>% 
  summarise(start = min(dates), end = max(dates)) %>% 
  mutate(group = "Q_Def") %>% 
  rename(event = Q_Def)
  )

gg_vistime(graphtabelle)
```


## Graph: Number of separation orders per person
```{r Anzahl-an-Absonderungen-pro-Person, fig.cap="Anzahl an Absonderungen pro Person"}
p1 <- df %>% group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(n)) +
  ester_theme() +
  geom_bar(fill = brewer.pal(3, mypalette)[3]) +
  coord_cartesian(xlim =c(1, 5)) +
  ggtitle("Anzahl an Isolationen und Quarantänen") 

p2 <- df %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(n)) +
  ester_theme() +
  geom_bar(fill = brewer.pal(3, mypalette)[1]) +
  coord_cartesian(xlim =c(1, 5)) +
  ggtitle("Anzahl an Isolationen") 
p3 <- df %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(n)) +
  ester_theme() +  
  coord_cartesian(xlim =c(1, 5)) +
  geom_bar(fill = brewer.pal(3, mypalette)[2]) +
  ggtitle("Anzahl an Quarantänen") 

p_gesamt <- grid.arrange(p1,p2,p3)
ggsave("graph/zeitenuebersicht.png", p_gesamt)
```


# Linear models
## Linear model of influence an quarantine duration
```{r}
summary(lm(as.numeric(dauer)~AgeGroup+Q_Duration, df %>% filter(DatensatzKategorie == "Kontakt-COVID-19")))
```

## Linear model of influence an isolation duration
```{r}
summary(lm(as.numeric(dauer)~AgeGroup+I_Duration, df %>% filter(DatensatzKategorie == "COVID-19")))
```


## Session Info
```{r}
sessionInfo()
```

