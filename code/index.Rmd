---
title: Covid-19 isolation and quarantine orders in a district of Berlin, Germany How many, how long, to whom and predictive factors
date: "`r format(Sys.time(), '%d. %B %Y')`"
author: Jakob Schumacher, Lisa Kühne, Sophie Bruessermann, Benjamin Geisler, Sonja Jäckle
output:
  html_document:
    df_print: paged
    toc: FALSE
    toc_float: FALSE
    theme: lumen
    code_folding: hide
    number_sections: true
    fig_width: 7
    fig_height: 6
    fig_caption: true
  bookdown::html_document2:
    df_print: paged
  pdf_document:
    keep_tex: yes
params:
  completerun: FALSE
---
![](https://www.horizont.net/news/media/32/Das-neue-Berlin-Logo-315209.jpeg){width=30%}
![](https://www.ultrasoundsymposium.org/wp-content/uploads/2017/08/fhg-1.gif){width=30%}
![](https://www.lsc-digital-public-health.de/images/partners/leibniz-institut-bips.png){width=30%}

# About this Repository
The following R-Script calculates all the necessary numbers and figures for a publication. All necessary files to reproduce are available. 

## Aim of the publication

## What you need to reproduce the script
- All necessary files 
- R, Rstudio and the packages (see setup chunk)
- Maybe you need to adjust the folder and the root dir (see setup chunk)  
- Install the necessary fonts (see setup chunk)

## About the authors

## About Reinickendorf

# Methods

## Load packages
```{r setup packages}
pacman::p_load(here,         # File locator
               tidyverse,    # data management + ggplot2 graphics
               ggthemes,     # for additional theme of ggplot
               janitor,      # additional cleaning
               lubridate,    # working with dates
               vistime,      # Timeline graph
               DescTools,    # %overlaps% function 
               mmtable2,     # Making nice tables
               knitr,        # Output
               pander,       # Produce nice tables  
               RColorBrewer, # Colours in graphs
               tidyquant,    # Moving averages
               gridExtra,    # Several plots into one
               grid          # Text abilities of ggplot
               )
```


## Setting options for knitr, ggplot, fonts 
```{r setup output options}
# Disabeling scientific notation
options(scipen = 999)

# Adjust the root directory. Depending on the placement of your R-Project-File you need to adjust this 
knitr::opts_knit$set(root.dir = here())

# Create correct figure caption
knitr::opts_knit$set(eval.after = 'fig.cap')

# Adjust the big mark for large numbers
knitr::knit_hooks$set(inline = function(x) { prettyNum(x, big.mark=" ") })


# Setting the ggplot theme
ester_theme <- function() {
  theme(
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(family = "PT-Regular"),
    legend.position = "bottom",
    legend.direction = "horizontal"
  )
}

# Create colour palette for ggplot
mypalette = 'Set1'

# Fonts
# Setup: You will only need to run this once, but it will take a few minutes to finish 
# Install https://fonts.google.com/specimen/PT+Sans on your local computer
# install.packages("extrafont")
# library(extrafont)
# font_import() # Import all the .ttf files from your system. On Linux see also: https://stackoverflow.com/questions/61204259/how-can-i-resolve-the-no-font-name-issue-when-importing-fonts-into-r-using-ext

```

## Creating storage variables
```{r creating storage variables}
# This variable stores all numbers needed for the method section in the script
methodslist <- list()
resultslist <- list()

# Create a check function for testing purposes
checkanonids <- function(){
# df %>% count(AnonID) %>% filter(n>3) %>% pull(AnonID)
print(df %>% filter(AnonID=="ID021580"))
print(df %>% filter(AnonID == "ID037188"))
print(df %>% filter(AnonID == "ID015472"))
}
```

## External input
```{r Methods external input, eval = params$completerun}
# Dates
methodslist$StartDate <- dmy("03.03.2020")
methodslist$EndDate <- dmy("18.12.2021")
methodslist$StartDateKP <- dmy("25.05.2020")
methodslist$EndDateKP <- dmy("18.12.2021")

# verified wrong IDs
wrong_id = "ID000977"
wrong_id2 = "#NV"
```


## Population data from Berlin Reinickendorf, Germany
```{r population data, eval = params$completerun}
demographiedaten <-   read_delim("data/EWR202012E_Matrix.csv", delim = ";", show_col_types = FALSE) %>% 
  filter(BEZ == "12")  %>% 
  summarise('0 to 6' = sum(E_E00_01 + E_E01_02  + E_E02_03  + E_E03_05  + E_E05_06  +E_E06_07),
            '7 to 17' = sum(E_E07_08 + E_E08_10  + E_E10_12 + E_E12_14 + E_E14_15  + E_E15_18),
            '18 to 64' = sum(E_E18U25 + E_E25U55 + E_E55U65),
            '65 to 110' = sum(E_E65U80 + E_E80U110)) %>% 
  pivot_longer(cols = everything())
```


## Reading and tidying the dataset
```{r reading and tidying, eval = params$completerun}
# reading in the date
df <- read_delim("data/absonderungslast_ohneNamen_altersgruppe2.csv", delim = ",", show_col_types = FALSE)

# Add RowID (this is needed for the purr::map function)
df <- df %>% rowid_to_column()

# Correct SurvNet mistake
df <- df %>% rename(AbsonderungBis = AbsonderunBis)

# Adjust date variables and calculate duration
df <- df %>% 
  mutate(Meldedatum = as.Date(Meldedatum, format = "%d.%m.%Y")) %>% 
  mutate(AbsonderungVon = as.Date(AbsonderungVon, format = "%d.%m.%Y")) %>% 
  mutate(AbsonderungBis = as.Date(AbsonderungBis, format = "%d.%m.%Y")) %>% 
  mutate(Meldemonat = paste(year(AbsonderungVon), format.Date(AbsonderungVon, "%m"), sep = "_")) %>% 
  mutate(Meldewoche = paste(year(AbsonderungVon), format.Date(AbsonderungVon, "%W"), sep = "_")) %>% 
  mutate(dauer = as.numeric(AbsonderungBis - AbsonderungVon)) 


# create time periods used for filtering
df <- df %>% 
  mutate(abstandVonBis = AbsonderungBis - AbsonderungVon) %>% 
  mutate(abstandMeldedatumVon = Meldedatum - AbsonderungVon)

# Switch AgeGroup into an ordered factor
df <- df %>% 
  mutate(AgeGroup = recode_factor(AgeGroup, "<7" = "0 to 6", "7bis17" = "7 to 17", "18bis64" = "18 to 64", ">64" = "65 to 110", .ordered = TRUE))
```


##  Filtering
```{r Filtering, eval = params$completerun}
# Saving for publication
methodslist$queried <- nrow(df)

# finding entries that meet the case definition
df <- df %>% 
  mutate(definitionvar = "notdefined") %>% 
  mutate(definitionvar = ifelse(!is.na(AbsonderungVon) & !is.na(AbsonderungBis), "defined", definitionvar)) %>% 
  mutate(definitionvar = ifelse(!is.na(AbsonderungVon) & !is.na(AbsonderungBis), "defined", definitionvar)) %>% 
  mutate(definitionvar = ifelse(AnonID == wrong_id, "wrongID", definitionvar)) %>% 
  mutate(definitionvar = ifelse(AnonID == wrong_id2, "wrongID", definitionvar)) 
# saving for results
methodslist$definitionvar <- table(df$definitionvar)
# actual filtering
df <- df %>% filter(definitionvar == "defined")

# finding entries whith a date that is not in the timeframe
df <- df %>% 
  mutate(outofrange = "inrange") %>% 
  mutate(outofrange = ifelse(AbsonderungVon < methodslist$StartDate | AbsonderungVon > (methodslist$EndDate + 14), "outofrange", outofrange)) %>%
  mutate(outofrange = ifelse(AbsonderungBis < methodslist$StartDate | AbsonderungBis > (methodslist$EndDate + 14), "outofrange", outofrange)) %>%
  mutate(outofrange = ifelse(Meldedatum < methodslist$StartDate | Meldedatum > (methodslist$EndDate + 14), "outofrange", outofrange)) 
# saving for results
methodslist$outofrange <- table(df$outofrange)
# actual filtering
df <- df %>% filter(outofrange == "inrange")

# finding entries with a presumable data entry error
df <- df  %>% 
  mutate(filtervar = "korrekt") %>% 
  mutate(filtervar = ifelse(abstandVonBis > 30, "typingerror", filtervar)) %>%
  mutate(filtervar = ifelse(abstandVonBis < 1, "typingerror", filtervar)) %>%
  mutate(filtervar = ifelse(abstandMeldedatumVon < -30, "typingerror", filtervar)) %>%
  mutate(filtervar = ifelse(abstandMeldedatumVon > 30, "typingerror", filtervar)) 
# saving for results
methodslist$wrongEntries <- table(df$filtervar) 
# actual filtering
df <- df %>%  filter(filtervar == "korrekt") 

# cleaning up  
df <- df %>% select(-abstandMeldedatumVon, -abstandVonBis, -filtervar, -outofrange, -definitionvar)
```

## Filtering and adjusting duplicate entries
This part looks for duplicated separation orders. It takes the maximum and the minimum of duplicated entries 
```{r Duplicate entries, eval = params$completerun}
# This function creates a list of numbers which is needed for the other functions
overlapcheck_pairs <- function(highest = 10){
  mytibble <- tibble(value = 1:highest) %>% 
    expand(value, value1 = value) %>% 
    filter(value < value1) 
  mylist <- map(1:nrow(mytibble), ~c(mytibble$value[.x], mytibble$value1[.x]))
  mylist
}
# This call creates the list with the function overlapcheck_pairs
pairslist <- map(1:(df %>% count(AnonID) %>% top_n(1, wt = n) %>% pull(n))[1], ~overlapcheck_pairs(.x)) # Legt die Pairsliste an

# This function checks wheter two entries overlap
overlapcheck <- function(data_input, pair) {
  i <- pair[1]
  j <- pair[2]
  first <- c(data_input$AbsonderungVon[i], data_input$AbsonderungBis[i])
  second <- c(data_input$AbsonderungVon[j], data_input$AbsonderungBis[j])
if(first %overlaps% second) {
  data_input$AbsonderungVon[i] <- min(c(first, second))
  data_input$AbsonderungBis[i] <- max(c(first, second))
  data_input <- data_input[-c(j),]
}
  data_input
}

# This function uses the function overlapcheck on the table of one person and gives the result with only correct entries. 
overlapcheck_concise <- function(data_input, testsubject) {
  tdf <- data_input %>% filter(AnonID == testsubject) 
  mylist <- pairslist[[nrow(tdf)]]
  allvalues <- map(mylist, ~overlapcheck(tdf, .x))
  table <- bind_rows(allvalues) 
  table %>% 
    count(rowid) %>% 
    filter(n==length(mylist)) %>% 
    select(-n) %>%  
    left_join(table, by = "rowid") %>% 
    distinct() %>% 
    group_by(rowid) %>% 
    mutate(AbsonderungVon = min(AbsonderungVon)) %>% 
    mutate(AbsonderungBis = max(AbsonderungBis)) %>% 
    distinct()
}

# To save calculation time the complete dataset is split up. I am sure there is an easier way but this is a safe way.
kps <- df %>% filter(DatensatzKategorie == "Kontakt-COVID-19")
faelle <- df %>% filter(DatensatzKategorie == "COVID-19")
einzelne_kps <- kps %>% count(AnonID) %>% filter(n==1) %>% pull(AnonID)
doppelte_kps <- kps %>% count(AnonID) %>% filter(n>1) %>% pull(AnonID)
einzelne_faelle <- faelle %>% count(AnonID) %>% filter(n==1) %>% pull(AnonID)
doppelte_faelle <- faelle %>% count(AnonID) %>% filter(n>1) %>% pull(AnonID)
einzelne_kps_df <- kps %>% filter(AnonID %in% einzelne_kps)
doppelte_kps_df <- kps %>% filter(AnonID %in% doppelte_kps)
einzelne_faelle_df <- faelle %>% filter(AnonID %in% einzelne_faelle)
doppelte_faelle_df <- faelle %>% filter(AnonID %in% doppelte_faelle)

# These functions do the actual work of adjusting the overlapping periods
doppelte_faelle_df_bereinigt <- bind_rows(map(doppelte_faelle, ~overlapcheck_concise(data_input = doppelte_faelle_df, testsubject = .x)))
doppelte_kps_df_bereinigt <- bind_rows(map(doppelte_kps, ~overlapcheck_concise(data_input = doppelte_kps_df, testsubject = .x)))

# Saving for the publication
methodslist$doppeltefaelle <- nrow(doppelte_faelle_df) - nrow(doppelte_faelle_df_bereinigt)
methodslist$doppeltekps <- nrow(doppelte_kps_df) - nrow(doppelte_kps_df_bereinigt)

# Putting the table back together
df <- bind_rows(doppelte_faelle_df_bereinigt, doppelte_kps_df_bereinigt, einzelne_faelle_df, einzelne_kps_df) %>% ungroup()
```


## Correct quarantine if it overlaps with isolation
This functions checks for overlapping quarantine and isolation orders. 

> The following variantes are possible
> 1 
> KP   |----|
> Case |----|
> Filter min(kp)>=min(case)
> result should be:  delete(KP)
> 2
> KP      |----|
> Case |----|
> Filter min(kp)>=min(case)
> result should be: delete(kp)
> 4
> KP    |--|
> Case |----|
> Filter min(kp)>=min(case)
> result should be:  delete(KP) 
> 6
> KP   |--|
> Case |----|
> Filter min(kp)>=min(case)
> result should be: delete(KP)
> KP   |----|
> Case |--|
> Filter min(kp)>=min(case) 
> result should be: delete(kp)
> 8
> KP    |---|
> Case |----|
> Filter min(kp)>=min(case)
> result should be: delete(kp)
> 3
> KP   |----|
> Case    |----|
> Filter min(kp)<min(case)
> result should be:  min(KP) - min(Case)
> 5
> KP   |----|
> Case  |--|
> Filter min(kp)<min(case)
> result should be: min(KP) - min(case)
> 9
> KP   |----|
> Case  |---|
> Filter min(kp)<min(case)
> result should be: min(kp) - min(case)

For examples check the following AnonIDs: ID000004, ID000002, ID000435

```{r quarantine-isolation-overlap, eval = params$completerun}
# overlappingQandI_df <- tibble(AnonID = unique(df$AnonID), overlappingIDs = rep(NA, length(unique(df$AnonID))))

# This function checks for overlap and adjusts the quarantine if needed
adjustoverlapquarantine <- function(data_input, pair) {
  i <- pair[1]
  j <- pair[2]
  first <- c(data_input$AbsonderungVon[i], data_input$AbsonderungBis[i])
  second <- c(data_input$AbsonderungVon[j], data_input$AbsonderungBis[j])
  firstsequence <- seq(data_input$AbsonderungVon[i], data_input$AbsonderungBis[i], by = 1)
  secondsequence <- seq(data_input$AbsonderungVon[j], data_input$AbsonderungBis[j], by = 1)
  if(first %overlaps% second) {
    if(data_input$DatensatzKategorie[i] == "COVID-19" & data_input$DatensatzKategorie[j] == "Kontakt-COVID-19") {
      if(min(secondsequence)<min(firstsequence)){
        data_input$AbsonderungVon[j] <- min(secondsequence)
        data_input$AbsonderungBis[j] <- min(firstsequence)  
      } else {data_input <- data_input[-c(j),]}
      
    }  else if(data_input$DatensatzKategorie[i] == "Kontakt-COVID-19" & data_input$DatensatzKategorie[j] == "COVID-19") {
      if(min(firstsequence)<min(secondsequence)){
        data_input$AbsonderungVon[i] <- min(firstsequence)
        data_input$AbsonderungBis[i] <- min(secondsequence)  
      } else {data_input <- data_input[-c(i),]}
    }
  }
  data_input
}

# This function applies the adjustoverlapquarantine to every testsubject
adjustoverlapquarantine_concise <- function(data_input, testsubject) {
  tdf <- data_input %>% filter(AnonID == testsubject) 
  mylist <- pairslist[[nrow(tdf)]]
  allvalues <- map(mylist, ~adjustoverlapquarantine(tdf, .x))
  table <- bind_rows(allvalues) 
  table <- table %>% 
    count(rowid) %>% 
    filter(n==length(mylist)) %>% 
    select(-n) %>%  
    left_join(table, by = "rowid") %>% 
    distinct() %>% 
    group_by(rowid) %>% 
    mutate(AbsonderungVon = min(AbsonderungVon)) %>% 
    mutate(AbsonderungBis = min(AbsonderungBis)) %>% 
    distinct()
  
  table 
}


# Table is split up to save calculation time
einzelne_anonIDs <- df %>% count(AnonID) %>% filter(n==1) %>% pull(AnonID)
doppelte_anonIDs <- df %>% count(AnonID) %>% filter(n>1) %>% pull(AnonID)

einzelne_anonIDs_df <- df %>% filter(AnonID %in% einzelne_anonIDs)
doppelte_anonIDs_df <- df %>% filter(AnonID %in% doppelte_anonIDs)

# This function actually does all the work and puts together the functions above
doppelte_anonIDs_df_bereinigt <- bind_rows(map(doppelte_anonIDs, ~adjustoverlapquarantine_concise(data_input = doppelte_anonIDs_df, testsubject = .x)))

# Saving for the results
methodslist$ueberlappendeFalleKP <- nrow(doppelte_anonIDs_df) - nrow(doppelte_anonIDs_df_bereinigt) 
 
# The table is put together again
df <- bind_rows(doppelte_anonIDs_df_bereinigt, einzelne_anonIDs_df) %>% ungroup()
```


## Find adjoining quarantines and isolations 
```{r quarantine-isolation-adjoining, eval = params$completerun}

# Set empty value
df$adjoiningQandI <- NA

# what counts as adjoining 
adjoiningwhentimedifference <- seq(0,6) 

adjoincheck <- function(data_input, pair) {
  i <- pair[1] # this is number one
  j <- pair[2] # this is number two
  twoafterone <- data_input$AbsonderungVon[j] - data_input$AbsonderungBis[i]  # if one after two its positive
  oneaftertwo <- data_input$AbsonderungVon[i] - data_input$AbsonderungBis[j] # if two after one its positive
  if(data_input$DatensatzKategorie[i] == "COVID-19" & data_input$DatensatzKategorie[j] == "Kontakt-COVID-19") {
    if(oneaftertwo %in% adjoiningwhentimedifference){
      data_input$adjoiningQandI[i] <- oneaftertwo
      data_input$adjoiningQandI[j] <- oneaftertwo
    } 
  }  else if(data_input$DatensatzKategorie[i] == "Kontakt-COVID-19" & data_input$DatensatzKategorie[j] == "COVID-19") {
    if(twoafterone %in% adjoiningwhentimedifference){
      data_input$adjoiningQandI[i] <- twoafterone
      data_input$adjoiningQandI[j] <- twoafterone
    }  
  }
  data_input
}
 
adjoincheck_concise <- function(data_input, testsubject) {
  tdf <- data_input %>% filter(AnonID == testsubject) 
  mylist <- pairslist[[nrow(tdf)]]
  allvalues <- map(mylist, ~adjoincheck(tdf, .x))
  table <- bind_rows(allvalues) 
  changedrowids <- table %>% filter(!is.na(adjoiningQandI)) %>% distinct()
  notchangedrowids <- table %>% filter(!rowid %in% changedrowids$rowid) %>% select(rowid) %>% distinct() %>% left_join(tdf, by = "rowid")
  data_output <- bind_rows(changedrowids, notchangedrowids)
  data_output
}

# Split up the df to save computing time
einzelne_anonIDs <- df %>% count(AnonID) %>% filter(n==1) %>% pull(AnonID)
doppelte_anonIDs <- df %>% count(AnonID) %>% filter(n>1) %>% pull(AnonID)
einzelne_anonIDs_df <- df %>% filter(AnonID %in% einzelne_anonIDs)
doppelte_anonIDs_df <- df %>% filter(AnonID %in% doppelte_anonIDs)

# This call does all the work 
doppelte_anonIDs_df_bereinigt <- bind_rows(map(doppelte_anonIDs, ~adjoincheck_concise(data_input = doppelte_anonIDs_df, testsubject = .x)))

# The df is put together again
df <- bind_rows(doppelte_anonIDs_df_bereinigt, einzelne_anonIDs_df)

```


## Time periods
```{r timeperiods, eval = params$completerun}
# quarantine duration
Q_Duration <- bind_rows(
  tibble(
    dates = seq(methodslist$StartDate, dmy("30.11.2020"), by=1),
    Q_Duration = "Q_Duration_1",
    Q_Duration_value = "Gesundheitsüberwachung bis zum 14. Tag nach dem letzten Kontakt mit dem bestätigten 2019-nCoV-Fall [...] Kontaktreduktion nach Maßgabe des Gesundheitsamtes. Dies kann, gemäß § 31 IfSG, die Isolation im Krankenhaus beinhalten, oder eine Selbstisolierung während der weiteren diagnostischen Abklärung unter Einhaltung infektionshygienischer Maßnahmen.",
    Q_Duration_shortvalue = "14 days",
    Q_Duration_url = "https://web.archive.org/web/20200212092830/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Kontaktperson/Management.html"
  ),
  tibble(
    dates = seq(dmy("01.12.2020"),dmy("15.02.2021"), by=1),
    Q_Duration = "Q_Duration_2",
    Q_Duration_value = "Häusliche Absonderung für 14 Tage (Quarantäne) - gerechnet ab dem letzten Tag des Kontaktes zum Quellfall. Die häusliche Absonderung kann auf 10 Tage verkürzt werden, wenn ein negativer SARS-CoV-2-Test vorliegt; der Test darf frühestens am zehnten Tag der Quarantäne durchgeführt werden.",
    Q_Duration_shortvalue = "14 days - out with PoC-Test after 10 days",
    Q_Duration_url = "https://web.archive.org/web/20201203010328/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Kontaktperson/Management.html",
  ),
  tibble(
    dates = seq(dmy("16.02.2021"),dmy("08.09.2021"), by=1),
    Q_Duration = "Q_Duration_3",
    Q_Duration_value = "Kontaktpersonen der Kategorie 1 müssen sich unverzüglich für 14 Tage häuslich absondern (Quarantäne) - gerechnet ab dem letzten Tag des Kontaktes zum Quellfall.",
    Q_Duration_shortvalue = "14 Tage",
    Q_Duration_url = "https://web.archive.org/web/20210217232253/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Kontaktperson/Management.html"
  ),
  tibble(
    dates = seq(dmy("09.09.2021"),methodslist$EndDate+14, by=1), 
    Q_Duration = "Q_Duration_4",
    Q_Duration_value = "10 Tage Quarantäne ohne abschließenden Test. 5 Tage mit PCR-Test bei Probenentnahme frühestens am 5. Tag. Bei Personen, die regelmäßig im Rahmen einer seriellen Teststrategie getestet werden (z.B. Schülerinnen und Schüler), kann der negative Nachweis auch mittels qualitativ hochwertigen Antigen-Schnelltests erwogen werden. 7 Tage mit Antigen-Schnelltest bei Probenentnahme frühestens am 7. Tag.",
    Q_Duration_shortvalue = "10 Tage Quarantäne ohne abschließenden Test, 5 Tage mit PCR-Test bei Probenentnahme frühestens am 5. Tag. 7 Tage mit Antigen-Schnelltest",
    Q_Duration_url = "https://web.archive.org/web/20210909213747/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Kontaktperson/Management.html"
  )
)

# isolation duration
I_Duration <- bind_rows(
  tibble(
    dates = seq(methodslist$StartDate,dmy("01.07.2020"), by=1), 
    I_Duration = "I_Duration_1",
    I_Duration_value = "Kriterien zur Entlassung aus der häuslichen Isolierung: Frühestens 14 Tage nach Symptombeginn UND Symptomfreiheit seit mind. 48 Stunden bezogen auf die akute COVID-19-Erkrankung", 
    I_Duration_shortvalue  = "14 days", 
    I_Duration_url = "https://web.archive.org/web/20200623101259/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Entlassmanagement.html"
  ),
  tibble(
    dates = seq(dmy("02.07.2020"),dmy("30.03.2021"), by=1) ,
    I_Duration = "I_Duration_2",
    I_Duration_value = "Mind. 48 Stunden Symptomfreiheit PLUS Frühestens 10 Tage nach Symptombeginn",
    I_Duration_shortvalue  = "10 Tage Isolierung",
    I_Duration_url = "https://web.archive.org/web/20200715191510/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Entlassmanagement.html"
  ),
  tibble(
    dates = seq(dmy("31.03.2021"),methodslist$EndDate+14, by=1)  ,
    I_Duration = "I_Duration_3",
    I_Duration_value = "Für Patienten mit leichtem oder mildem/ moderatem Krankheitsverlauf (gemäß WHO-Definition) und ungestörter Immunkompetenz kann eine Entisolierung erfolgen, wenn (1) mindestens 14 Tage seit Auftreten der ersten Symptome verstrichen sind, (2) eine nachhaltige Besserung der akuten COVID-19-Symptomatik gemäß ärztlicher Beurteilung seit >48 h vorliegt und (3) ein negativer Antigentest.",
    I_Duration_shortvalue  = "14 Tage Isolierung",
    I_Duration_url = "https://web.archive.org/web/20210331212322/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Entlassmanagement.html",
  )
)


# contact person defintion
Q_Def <- bind_rows(
  tibble(
    dates =  seq(dmy("11.02.2020"),dmy("30.03.2021"), by=1), 
    Q_Def = "Q_Def_1",
    Q_Def_value = "Personen mit kumulativ mindestens 15-minütigem Gesichts- (face-to-face) Kontakt, z.B. im Rahmen eines Gesprächs. Dazu gehören z.B. Personen aus Lebensgemeinschaften im selben Haushalt. Personen mit direktem Kontakt zu Sekreten oder Körperflüssigkeiten, insbesondere zu respiratorischen Sekreten eines bestätigten COVID-19-Falls, wie z.B. Küssen, Kontakt zu Erbrochenem, Mund-zu-Mund Beatmung, Anhusten, Anniesen, etc. Personen, die nach Risikobewertung durch das Gesundheitsamt mit hoher Wahrscheinlichkeit einer relevanten Konzentration von Aerosolen ausgesetzt waren (z.B. Feiern, gemeinsames Singen oder Sporttreiben in Innenräumen) Medizinisches Personal mit Kontakt zum bestätigten COVID-19-Fall im Rahmen von Pflege oder medizinischer Untersuchung (<= 2m), ohne verwendete Schutzausrüstung. Falls die Person früher als COVID-19 Fall gemeldet wurde ist keine Quarantäne erforderlich, es soll ein Selbstmonitoring erfolgen und bei Auftreten von Symptomen eine sofortige Selbst-Isolation und -Testung. Bei positivem Test wird die Kontaktperson zu einem Fall. Bei diesem sollten alle Maßnahmen ergriffen werden wie bei sonstigen Fällen auch (inkl. Isolation). Kontaktpersonen eines bestätigten COVID-19-Falls im Flugzeug: Passagiere, die direkter Sitznachbar des bestätigten COVID-19-Falls waren, unabhängig von der Flugzeit. Saß der COVID-19-Fall am Gang, so zählt der Passagier in derselben Reihe jenseits des Ganges nicht als Kontaktperson der Kategorie I, sondern als Kontaktperson der Kategorie II.  Besatzungsmitglieder oder andere Passagiere, sofern auf Hinweis des bestätigten COVID-19-Falls eines der anderen Kriterien zutrifft (z.B. längeres Gespräch; o.ä.).",
    Q_Def_shortvalue  = "15 min. Group",
    Q_Def_url  = "https://web.archive.org/web/20200815104700/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Kontaktperson/Management.html"
  ),
  tibble(
    dates = seq(dmy("31.03.2021"),dmy("19.05.2021"), by=1),
    Q_Def = "Q_Def_2",
    Q_Def_value = "Enger Kontakt (<1,5 m, Nahfeld) länger als 10 Minuten ohne adäquaten Schutz# (adäquater Schutz = Fall und Kontaktperson tragen durchgehend und korrekt MNS [Mund-Nasen-Schutz] oder FFP2-Maske). Gespräch mit dem Fall (face-to-face-Kontakt, <1,5 m, unabhängig von der Gesprächsdauer) ohne adäquaten Schutz# (adäquater Schutz = Fall und Kontaktperson tragen durchgehend und korrekt MNS [Mund-Nasen-Schutz] oder FFP2-Maske). Gleichzeitiger Aufenthalt von Kontaktperson und Fall im selben Raum mit wahrscheinlich hoher Konzentration infektiöser Aerosole unabhängig vom Abstand für > 10 Minuten, auch wenn durchgehend und korrekt MNS (Mund-Nasen-Schutz) oder FFP2-Maske getragen wurde. Vollständig gegen COVID-19 geimpfte Personen sind nach Exposition zu einem bestätigten SARS-CoV-2-Fall von Quarantäne-Maßnahmen ausgenommen, ebenso wie Personen, die in der Vergangenheit eine PCR-bestätigte und symptomatische COVID-19-Erkrankung durchgemacht haben („Genesene“) und mit einer Impfstoffdosis geimpft sind.",
    Q_Def_shortvalue  = "10 min. + Group + VaccinatedNot",
    Q_Def_url  = "https://web.archive.org/web/20210407214300/https://www.rki.de/DE/Content/InfAZ/N/Neuartiges_Coronavirus/Kontaktperson/Management.html"  
  ),
  tibble(
    dates =  seq(dmy("20.05.2021"), methodslist$EndDate, by=1),
    Q_Def = "Q_Def_3",
    Q_Def_value = "    Enger Kontakt (<1,5 m, Nahfeld) länger als 10 Minuten ohne adäquaten Schutz# (adäquater Schutz = Fall und Kontaktperson tragen durchgehend und korrekt MNS [Mund-Nasen-Schutz] oder FFP2-Maske). Gespräch mit dem Fall (Face-to-face-Kontakt, <1,5 m, unabhängig von der Gesprächsdauer) ohne adäquaten Schutz# (adäquater Schutz = Fall und Kontaktperson tragen durchgehend und korrekt MNS [Mund-Nasen-Schutz] oder FFP2-Maske) oder direkter Kontakt (mit respiratorischem Sekret). Gleichzeitiger Aufenthalt von Kontaktperson und Fall im selben Raum mit wahrscheinlich hoher Konzentration infektiöser Aerosole unabhängig vom Abstand für > 10 Minuten, auch wenn durchgehend und korrekt MNS (Mund-Nasen-Schutz) oder FFP2-Maske getragen wurde. \n Coronavirus-Update (Internes Dokument des Gesundheitsamtes Reinickendorf): Umgang mit Kontaktpersonen in Schulen Wenn wir einen Fall in einer Schulklasse hatten, wird die gesamte Klasse über eine Fernfeldübertragung nur noch bei den folgenden Konstellationen in Quarantäne gesteckt: 1) Es sind schon Übertragungen in der Klasse in der zu bewertenden Situation bekannt geworden 2) Es wurde gar nicht gelüftet und die Zeit zusammen im Raum war über 2h. 3) Sonderfälle, bei dem grob viele Hygieneregeln missachtet wurden, nach Rücksprache. Davon unbenommen bleibt aber, dass die Personen durch eine Nahfeldübertragung Kontaktpersonen geworden sind. Zum Beispiel die besten Kumpels in der Klasse, die eng sitzenden Sitznachbarn, die Erziehungskraft, die das Kind ganz eng betreut hat.",
    Q_Def_shortvalue  = "10 min. + Indidividual children + Unvaccinated dont have to go",
    Q_Def_url  = "Corona-Update",
  )
)


# join the time periods
zeiten <- tibble(dates =seq(methodslist$StartDate, methodslist$EndDate, by = 1)) %>% 
  left_join(Q_Def, by = "dates") %>% 
  left_join(I_Duration, by = "dates") %>% 
  left_join(Q_Duration, by = "dates")


# Join with the main dataset
df <- df %>% 
  left_join(zeiten, by = c("AbsonderungVon" = "dates"))
```

## Save datasets
```{r saving_datasets, eval = params$completerun}
saveRDS(df, paste0("data/", today(), "-df.rdata"))
saveRDS(methodslist, paste0("data/", today(), "-methodslist.rdata"))
saveRDS(demographiedaten, paste0("data/", today(), "-demographiedaten.rdata"))
saveRDS(zeiten, paste0("data/", today(), "-zeiten.rdata"))

# rm(list=ls())
```

# Results
```{r Results}
# Hier wird die gespeicherte Tabelle eingelesen
df <- readRDS(paste0("data/2022-04-12-df.rdata")) %>% ungroup()
methodslist <- readRDS(paste0("data/2022-04-12-methodslist.rdata"))
demographiedaten <- readRDS(paste0("data/2022-04-12-demographiedaten.rdata"))
zeiten <- readRDS(paste0("data/2022-04-12-zeiten.rdata"))
```

## Calculate numbers and incidence
```{r N_and_incidence}
# N quarantines
resultslist$AnzahlQAgegroup <- df %>% filter(DatensatzKategorie == "Kontakt-COVID-19") %>% group_by(AgeGroup) %>% summarise(n = n()) %>% pull(n)
resultslist$GesamtQ <- sum(resultslist$AnzahlQAgegroup) 

# N isolations
resultslist$AnzahlIAgegroup <- df %>% filter(DatensatzKategorie == "COVID-19") %>%  group_by(AgeGroup) %>% summarise(n = n()) %>% pull(n)
resultslist$GesamtI <- sum(resultslist$AnzahlIAgegroup )

# Quarantines by population
resultslist$AnzahlQproBev <- round(100*resultslist$GesamtQ / demographiedaten %>% summarise(sum(value)) %>% pull(), 1)
resultslist$AnzahlQproBevAgegroup <- round(100 * resultslist$AnzahlQAgegroup  / demographiedaten$value, 1)

# Isolations by population
resultslist$AnzahlIproBev <- round(100*resultslist$GesamtI / demographiedaten %>% summarise(sum(value)) %>% pull(),1)
resultslist$AnzahlIproBevAgegroup <- round(100 * resultslist$AnzahlIAgegroup  / demographiedaten$value, 1)

resultslist$incidence <- df %>% 
  group_by(AgeGroup, DatensatzKategorie) %>% 
  summarise(n = n(), .groups = 'drop') %>% 
  left_join(demographiedaten, by= c("AgeGroup" = "name") ) %>% 
  rename(N = value) %>% 
  mutate(incidence = round(100*n/N)) %>% 
  mutate(DatensatzKategorie = recode_factor(DatensatzKategorie, "COVID-19" = "isolation", "Kontakt-COVID-19" = "quarantine"))
```


## Calculate time periods
```{r calculate_time_periods}
# Total duration of quarantine and isolation
resultslist$NQundI <- df %>% summarise(sum(dauer)) %>% pull()

# Quarantine duration
resultslist$MedianeDauerQ <- df %>% filter(DatensatzKategorie == "Kontakt-COVID-19") %>% summarise(quint = quantile(dauer)) %>% pull()
resultslist$MedianeDauerQ_Rec <- df %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(Q_Duration) %>% 
  summarise(quint = quantile(dauer, probs = 0.5 ), .groups = 'drop') 

# Isolation duration
resultslist$MedianeDauerI <- df %>% filter(DatensatzKategorie == "COVID-19") %>% summarise(quint = quantile(dauer)) %>% pull()
resultslist$MedianeDauerI_Rec <- df %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  group_by(I_Duration) %>% 
  summarise(quint = quantile(dauer, probs = 0.5 ), .groups = 'drop') 

resultslist$MedianeDauerAbsonderungAgeGroup <- df %>% group_by(DatensatzKategorie, AgeGroup) %>% summarise(quint = quantile(dauer), .groups = 'drop')


# total time
resultslist$totaltime_groups <- df %>% 
  group_by(DatensatzKategorie, AgeGroup) %>% 
  summarise(completeduration_days = sum(dauer), completeduration_years = sum(dauer) / 365, .groups = "drop_last") %>% 
  left_join(demographiedaten, by = c("AgeGroup" = "name")) %>% 
  mutate(percentage = round(100 * completeduration_days / sum(completeduration_days),1)) %>% 
  mutate(completeduration_person = round(completeduration_days / value,1)) %>% 
  ungroup()

resultslist$totaltime <- resultslist$totaltime_groups %>% group_by(DatensatzKategorie) %>% summarise(completeduration_total = round(sum(completeduration_years),1))

# print(resultslist$totaltime)
```

## Calculate ratio of quarantines to isolations
```{r quarantines_isolation_ratio}
resultslist$K_F_Verhaeltnis <- df %>%
  filter(AbsonderungVon > methodslist$StartDateKP) %>% 
  filter(AbsonderungVon < methodslist$EndDateKP) %>% 
  group_by(DatensatzKategorie) %>%
  summarise(n=n(), .groups = "drop") %>% 
  pivot_wider(names_from = DatensatzKategorie, values_from = n) %>% 
  janitor::clean_names() %>% 
  mutate(verhaeltnis = round(kontakt_covid_19 / covid_19,2)) %>% 
  pull(verhaeltnis)
  
resultslist$K_F_Verhaeltnis_QDef <- df %>%
  filter(AbsonderungVon > methodslist$StartDateKP) %>% 
  filter(AbsonderungVon < methodslist$EndDateKP) %>% 
  group_by(Q_Def, DatensatzKategorie) %>%
  summarise(n=n(), .groups = "drop") %>% 
  pivot_wider(names_from = DatensatzKategorie, values_from = n) %>% 
  janitor::clean_names() %>% 
  mutate(verhaeltnis = round(kontakt_covid_19 / covid_19,2))
```

## Quarantines and isolation per person
```{r quarantines_isolation_per_person}
resultslist$QundIproPerson <- df %>% 
  group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  count(number = n) %>% 
  mutate(Percentage= round( n / sum(n) * 100, 1)) 
  
resultslist$highestQundIproPerson <- df %>% group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  count(number = n) %>% 
  slice_max(number) %>% 
  pull(number)
```

## Find quarantines and isolations that adjoin
```{r adjoining_quarantines_and_isolation}
resultslist$ueberlappendeQundI <- df %>%
  filter(AbsonderungVon > methodslist$StartDateKP & AbsonderungVon < methodslist$EndDateKP) %>% 
  group_by(DatensatzKategorie, adjoiningQandI, AgeGroup, Q_Def) %>%
  count() %>% 
  mutate(result = NA) %>% 
  mutate(result = ifelse(adjoiningQandI == 0, "I_correct_after_Q", result)) %>% 
  mutate(result = ifelse(adjoiningQandI > 0, "I_too_long_after_Q", result)) %>% 
  mutate(result = ifelse(is.na(adjoiningQandI), "No_I_after_Q", result)) 

resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(Q_Def, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100)

resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(AgeGroup, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100)
```

## Text for Publication 
We extracted `r methodslist$queried` datasets from SurvNet. `r methodslist$outofrange[['inrange']]` entries fullfilled the definition `r methodslist$definitionvar[['notdefined']]` had missing dates, `r methodslist$definitionvar[['wrongID']]` entries had an IDs that did not lead to an existing person and `r methodslist$outofrange[['outofrange']]` did not have a beginning of the stay-at-home-order in the study period). We removed `r methodslist$wrongEntries[['typingerror']]` entries because they had a presumed typing error in one of the dates. We also removed `r methodslist$doppeltefaelle ` duplicated isolations and `r methodslist$doppeltekps ` duplicated quarantines. For XXXX quarantines we reduced the length by the overlap with a following isolation period. In the demographic data we found `r demographiedaten %>% summarise(sum(value)) %>% pull() ` inhabitants registered in Berlin Reinickendorf (`r demographiedaten %>% filter(name=="Kleiner7") %>% pull(value) ` in the age group <7; `r demographiedaten %>% filter(name=="Von7Bis17") %>% pull(value) ` in the age group 7-17; `r demographiedaten %>% filter(name=="Von18bis65") %>% pull(value) ` in the age group 18-64 and `r demographiedaten %>% filter(name=="Groesser64") %>% pull(value) ` in the age group >64).

*Analysis of quantity of isolation and quarantines:*  The local public health institute Reinickendorf von  Berlin did order `r resultslist$GesamtI ` isolations and `r resultslist$GesamtQ` quarantines. This amounts to a percentage of `r round(resultslist$GesamtI * 100 / demographiedaten %>% summarise(sum(value)),1) %>% pull()` isolations and `r round(resultslist$GesamtQ * 100 / demographiedaten %>% summarise(sum(value)) %>% pull(),1) ` quarantines of inhabitants. The number of isolations per 100 people in each age group was:  `r resultslist$incidence %>% filter(DatensatzKategorie == "isolation" & AgeGroup == "< 7") %>% pull(incidence) %>% round()` <7, `r resultslist$incidence %>% filter(DatensatzKategorie == "isolation" & AgeGroup == "7 to 17") %>% pull(incidence) %>% round()` 7-17, `r resultslist$incidence %>% filter(DatensatzKategorie == "isolation" & AgeGroup == "18 to 64") %>% pull(incidence) %>% round()` 18-64, `r resultslist$incidence %>% filter(DatensatzKategorie == "isolation" & AgeGroup == " > 64") %>% pull(incidence) %>% round()` >64. The number of quarantines per 100 people in each age group was:  `r resultslist$incidence %>% filter(DatensatzKategorie == "quarantine" & AgeGroup == "< 7") %>% pull(incidence) %>% round()` in the age group <7, `r resultslist$incidence %>% filter(DatensatzKategorie == "quarantine" & AgeGroup == "7 to 17") %>% pull(incidence) %>% round()` in the age group 7-17, `r resultslist$incidence %>% filter(DatensatzKategorie == "quarantine" & AgeGroup == "18 to 64") %>% pull(incidence) %>% round()` in the age group 18-64, `r resultslist$incidence %>% filter(DatensatzKategorie == "quarantine" & AgeGroup == " > 64") %>% pull(incidence) %>% round()` in the age group >64 (see figure \@ref(fig:incidence)). `r resultslist$QundIproPerson %>% filter(number==1) %>% pull(Percentage)` % of persons had one stay at home order (quarantine or isolation), `r resultslist$QundIproPerson %>% filter(number==2) %>% pull(Percentage)` % had two stay at home orders and `r resultslist$QundIproPerson %>% filter(number==3) %>% pull(Percentage)` % had three stay at home orders. The maximum number of stay at home orders per person was `r resultslist$highestQundIproPerson`.  

*Analysis of the duration of isolation quarantines:* The median duration for isolations was `r resultslist$MedianeDauerI["50%"] ` (interquartile range `r resultslist$MedianeDauerI["25%"]` - `r resultslist$MedianeDauerI["75%"] `). The duration did change in between different periods of recommendations. The median of the duration during the recommendation periods were: `r resultslist$MedianeDauerI_Rec %>% filter(I_Duration == "I_Duration_1") %>% select(quint) %>% pull()` for the period No. 1, `r resultslist$MedianeDauerI_Rec %>% filter(I_Duration == "I_Duration_2") %>% select(quint) %>% pull()` for the period No. 2, `r resultslist$MedianeDauerI_Rec %>% filter(I_Duration == "I_Duration_3") %>% select(quint) %>% pull()` for the period No. 3 and `r resultslist$MedianeDauerI_Rec %>% filter(I_Duration == "I_Duration_4") %>% select(quint) %>% pull()` for the period No. 4. The overall median duration for quarantines was `r resultslist$MedianeDauerQ["50%"] ` (interquartile range `r resultslist$MedianeDauerQ["25%"]` - `r resultslist$MedianeDauerQ["75%"] `). The median duration did differ between periods of different recommendations and age groups. The median of the duration during the recommendation periods were: `r resultslist$MedianeDauerQ_Rec %>% filter(Q_Duration == "Q_Duration_1") %>% select(quint) %>% pull()` for the period No. 1, `r resultslist$MedianeDauerQ_Rec %>% filter(Q_Duration == "Q_Duration_2") %>% select(quint) %>% pull()` for the period No. 2, `r resultslist$MedianeDauerQ_Rec %>% filter(Q_Duration == "Q_Duration_3") %>% select(quint) %>% pull()` for the period No. 3 and `r resultslist$MedianeDauerQ_Rec %>% filter(Q_Duration == "Q_Duration_4") %>% select(quint) %>% pull()` for the period No. 4. See figure \@ref(fig:duration). All together the public health agency ordered `r resultslist$totaltime %>% filter(DatensatzKategorie == "COVID-19") %>% pull(completeduration_total)` years of isolations and `r resultslist$totaltime %>% filter(DatensatzKategorie == "Kontakt-COVID-19") %>% pull(completeduration_total)` years of quarantine. 

*Analysis of the ratio of contact persons per case:* The overal ratio of contact persons was `r round(resultslist$K_F_Verhaeltnis,2)`. In the period of the contact person defintion no. 1 the ratio was `r resultslist$K_F_Verhaeltnis_QDef %>% filter(q_def == "Q_Def_1") %>% pull(verhaeltnis) ` in the period no. 2 the ratio was `r resultslist$K_F_Verhaeltnis_QDef %>% filter(q_def == "Q_Def_2") %>% pull(verhaeltnis)` and in the period no. 3 the ratio was: `r resultslist$K_F_Verhaeltnis_QDef %>% filter(q_def == "Q_Def_1") %>% pull(verhaeltnis)`. 

*Analysis of isolations following quarantines:* All together `r resultslist$Q_percentage` of quarantines had a following isolation. And `r  resultslist$I_percentage` isolations had a preceeding quarantine. This did differ between different periods and recommendations see figure \@ref(fig:adjoining-quarantines-and-isolation). A total of `r resultslist$isolationduringcontact` quarantines had a following isolation period. With the overall ratio of cases to contacts of `r resultslist$K_F_Verhaeltnis` and assuming of a total prevention of transmission this leads to `r round(resultslist$K_F_Verhaeltnis * resultslist$isolationduringcontact)` directly prevented/delayed cases.


# Tables
```{r totaltime_groups, echo = FALSE}
set.caption('Total duration of SARS-CoV-2 quarantines and isolations per age and the percentage of each age group from the total.') 
resultslist$totaltime_groups %>% 
    mutate(AgeGroup = recode_factor(AgeGroup,  "Kleiner7" = "< 7", "Von7Bis17" = "7 to 17", "Von18bis65" = "18 to 64", "Groesser64" = " > 64")) %>% 
  mutate(Type = recode_factor(DatensatzKategorie, "COVID-19" = "isolation", "Kontakt-COVID-19" = "quarantine")) %>% 
  select(Type, 'Age group' = AgeGroup, 'duration (d)' = completeduration_days, 'duration per person' = completeduration_person, 'Share in %' = percentage) %>% 
  pander()
```

# Graphs

## Graph: Incidence 
```{r incidence, fig.height= 3, fig.cap=paste("Incidence per 1000 of quarantines and isolations for inhabitants of Reinickendorf, Berlin between",  methodslist$StartDate, "and", methodslist$EndDate), error=FALSE, message=FALSE, warning=FALSE}
p1 <- resultslist$incidence %>% 
   mutate(AgeGroup = recode_factor(AgeGroup, "0 to 6" = "0 to 6", "7 to 17" = "7 to 17", "18 to 64" = "18 to 64", "65 to 110" = "65 to 110", .ordered = TRUE)) %>% 
  filter(DatensatzKategorie == "isolation") %>% 
  mutate(labelvalue = paste(incidence, "%")) %>% 
  ggplot(aes(x=AgeGroup, y=incidence, fill=DatensatzKategorie)) + 
  ester_theme() +
  geom_col() +
  scale_fill_brewer(palette = mypalette) +
  geom_text(aes(label = labelvalue), nudge_y = 3) + 
  xlab("") +
  ylab("isolations per 100 inhabitants") +
  ggtitle("Isolations by age group") +
  theme(legend.position = "none") 

p2 <- resultslist$incidence %>% 
   mutate(AgeGroup = recode_factor(AgeGroup, "0 to 6" = "0 to 6", "7 to 17" = "7 to 17", "18 to 64" = "18 to 64", "65 to 110" = "65 to 110", .ordered = TRUE)) %>% 
  filter(DatensatzKategorie == "quarantine") %>% 
  mutate(labelvalue = paste(incidence, "%")) %>% 
  ggplot(aes(x=AgeGroup, y=incidence, fill=DatensatzKategorie)) + 
  ester_theme() +
  geom_col(fill = brewer.pal(3, mypalette)[2]) +
  # scale_fill_brewer(palette = mypalette[2]) +
  geom_text(aes(label = labelvalue), nudge_y = 3) + 
  xlab("") +
  ylab("quarantines per 100 inhabitants") +
  ggtitle("Quarantine by age group") +
  theme(legend.position = "none") 

p_gesamt <- grid.arrange(p1,p2)

ggsave("graph/incidence.eps", p_gesamt)
```




## Graph: Quarantine duration by age group
```{r duration, fig.cap="Figure quarantine duration per age group", error=FALSE, message=FALSE, warning=FALSE}

p1 <- df %>%
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  filter(!is.na(Q_Duration)) %>% 
  group_by(AgeGroup) %>% 
  ggplot(aes(factor(AgeGroup), as.numeric(dauer))) +
  ester_theme() +
  geom_boxplot(outlier.shape = NA, fill = brewer.pal(3, mypalette)[2]) +
  facet_grid(~Q_Duration) +
  coord_cartesian(ylim = c(0, 23)) +
  ylab("duration in days") +
  xlab("") +
  ggtitle("Duration of quarantine in Reinickendorf Berlin")  +
  theme(axis.text.x = element_text(angle=45, vjust = 1, hjust=1))



p2 <- df %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  filter(!is.na(Q_Duration)) %>% 
  group_by(AgeGroup) %>% 
  ggplot(aes(factor(AgeGroup), as.numeric(dauer))) +
  ester_theme() +
  geom_boxplot(outlier.shape = NA) +
  # geom_violin(scale = "count") +
  facet_grid(~I_Duration) +
  coord_cartesian(ylim = c(0,28)) +
  geom_boxplot(outlier.shape = NA, fill = brewer.pal(3, mypalette)[1]) +
  ylab("duration in days") +
  xlab("") +
  ggtitle("Duration of isolation in Reinickendorf Berlin") +
  theme(axis.text.x = element_text(angle=45, vjust = 1, hjust=1))

p_gesamt <- grid.arrange(p1,p2)

ggsave("graph/duration.eps", p_gesamt)

```


## Graph: Adjoining quarantines and isolation
```{r adjoining-quarantines-and-isolation, fig.cap="Percentage of quarantines with an adjoining isolation or vice versa by definition period", error=FALSE, message=FALSE, warning=FALSE}

p1 <- resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(Q_Def, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100) %>%
  ungroup() %>% 
  filter(result == "I_correct_after_Q" | result == "I_too_long_after_Q") %>% 
  mutate(Q_Def = recode_factor(Q_Def, "Q_Def_1" = "Def_1", "Q_Def_2" = "Def_2", "Q_Def_3" = "Def_3", .ordered = TRUE)) %>% 
  mutate(result = recode_factor(result, "I_too_long_after_Q" = "Isolation missed", "I_correct_after_Q" = "Isolation starts after quarantine", .ordered = TRUE)) %>% 
  ggplot(aes(x=Q_Def, y = percentage, fill = result)) +
  geom_col() +
  ester_theme() +
  scale_fill_brewer(palette=mypalette) +
  scale_y_continuous(limits = c(0,21)) +
  ylab("%") +
  xlab("Contact person definition period") +
  theme(legend.position = "none")

p2 <- resultslist$ueberlappendeQundI %>%
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(AgeGroup, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100) %>%
  ungroup() %>% 
  filter(result == "I_correct_after_Q" | result == "I_too_long_after_Q") %>% 
  mutate(result = recode_factor(result, "I_too_long_after_Q" = "Isolation missed", "I_correct_after_Q" = "Isolation starts after quarantine", .ordered = TRUE)) %>% 
  ggplot(aes(x=AgeGroup, y = percentage, fill = result)) +
  geom_col() +
  ester_theme() +
  scale_fill_brewer(palette=mypalette) +
  scale_y_continuous(limits = c(0,21)) +
  ylab("%") +
  xlab("Age group") +
  theme(legend.position = "none")

p3 <- resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  group_by(Q_Def, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100) %>%
  ungroup() %>% 
  filter(result == "I_correct_after_Q" | result == "I_too_long_after_Q") %>% 
  mutate(Q_Def = recode_factor(Q_Def, "Q_Def_1" = "Def_1", "Q_Def_2" = "Def_2", "Q_Def_3" = "Def_3", .ordered = TRUE)) %>% 
  mutate(result = recode_factor(result, "I_too_long_after_Q" = "Isolation missed", "I_correct_after_Q" = "Isolation starts after quarantine", .ordered = TRUE)) %>% 
  ggplot(aes(x=Q_Def, y = percentage, fill = result)) +
  geom_col() +
  ester_theme() +
  scale_y_continuous(limits = c(0,40)) +
  scale_fill_brewer(palette=mypalette) +
  ylab("%") +
  xlab("Contact person definition period") +
  theme(legend.position = "none")

p4 <- resultslist$ueberlappendeQundI %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  group_by(AgeGroup, result) %>% 
  summarise(n = sum(n)) %>% 
  mutate(percentage = prop.table(n)*100) %>%
  ungroup() %>% 
  filter(result == "I_correct_after_Q" | result == "I_too_long_after_Q") %>% 
  mutate(result = recode_factor(result, "I_too_long_after_Q" = "Isolation missed", "I_correct_after_Q" = "Isolation starts after quarantine", .ordered = TRUE)) %>% 
  ggplot(aes(x=AgeGroup, y = percentage, fill = result)) +
  geom_col() +
  ester_theme() +
  scale_fill_brewer(palette=mypalette) +
  scale_y_continuous(limits = c(0,40)) +
  ylab("%") +
  xlab("Age group") +
  theme(legend.position = "none")

p_gesamt_1 <- grid.arrange(p1,p2, 
                           top = textGrob("Percentage of quarantines that were followed by an isolation period", gp = gpar(fontsize=14)), 
                           ncol = 2)
p_gesamt_2 <- grid.arrange(p3,p4,  
                           top = textGrob("Percentage of isolations that were preceeded by a quarantine period", gp = gpar(fontsize=14)), 
                           ncol = 2)
p_gesamt <- grid.arrange(p_gesamt_1, p_gesamt_2)


ggsave("graph/adjoining.eps", p_gesamt, width = 7, height = 7)

```


## Graph: Quarantines and isolation over time
```{r Quarantines-and-isolation-over-time, fig.cap="Quarantines and isolation over time", error=FALSE, message=FALSE, warning=FALSE}
df %>% 
  mutate(meldezeit = floor_date(AbsonderungVon, "week")) %>% 
  ggplot(aes(meldezeit, fill = DatensatzKategorie)) + 
  ester_theme() +
  geom_bar() +
  scale_fill_brewer(palette=mypalette) +
  ylab("n") +
  xlab("") +
  ggtitle("Number of quarantines and isolations") +
  theme(legend.position = "none")

ggsave("graph/numberovertime.eps", width = 7, height = 7)

```

# Addendum

## Text: Check number of countries with contact tracing
```{r number_of_countries_with_contact_tracing}
# Data from https://www.bsg.ox.ac.uk/research/research-projects/covid-19-government-response-tracker
# We claim that 
oxcgrt <- read_csv("data/OxCGRT_latest.csv")

numberofcountrieswithcontacttracing <- oxcgrt %>% 
  select(contacttracing = 'H3_Contact tracing', CountryName) %>% 
  filter(contacttracing>0) %>%
  select(CountryName) %>% 
  distinct() %>% 
  nrow()
  
numberofcountries <- oxcgrt %>% 
  select(CountryName) %>% 
  distinct() %>% 
  nrow()
```

`r numberofcountrieswithcontacttracing` of `r numberofcountries` countries do contact tracing.



## Graph: Overview of separation orders by week
```{r overview_figure, fig.cap = "separation order duration by week"}
df2 <- df %>% 
  mutate(meldezeit = floor_date(AbsonderungVon, "week"))  %>% 
  group_by(meldezeit, DatensatzKategorie, AgeGroup) %>% 
  mutate(durationsum = sum(dauer)/365)

df2 %>% ggplot(aes(x = meldezeit, y = durationsum, fill = AgeGroup)) +
  ester_theme() +
 geom_col() +
facet_wrap(~DatensatzKategorie + AgeGroup, ncol = 4) +
    # geom_vline(xintercept = floor_date(ymd("2020_10_01"), unit = "week")) +
  ylab("Duration in years") 
```


## Graph: Ratio-of-contact-person-to-case
```{r Ratio-of-contact-person-to-case, fig.cap="Ratio of contact person to case by defintion of contact person"}
 resultslist$K_F_Verhaeltnis_QDef %>% 
  ggplot(aes(x = q_def, y = verhaeltnis)) + 
  ester_theme() +
  geom_bar(stat = "identity") +
  ylab("ratio contact persons to case") +
  xlab("") +
  ggtitle("Ratio of contact person to case by defintion of contact person") 
```

## Graph: Quarantines per isolation ratio per month
```{r KP-pro-Fall-pro-Monat, fig.cap="KP pro Fall pro Monat"}
df %>% 
  group_by(Meldemonat, DatensatzKategorie) %>% 
  count() %>% 
  pivot_wider(names_from = DatensatzKategorie, values_from = n) %>% 
  janitor::clean_names() %>% 
  mutate(verhaeltnis = kontakt_covid_19/covid_19) %>% 
  na.omit() %>% 
  ggplot(aes(x = meldemonat, y = verhaeltnis)) +
  ester_theme() +
  geom_bar(stat = "identity") 
```

## Graph: Duration over time
```{r graph-dauer-über-die-Zeit, fig.height = 15, fig.cap="Absonderungsdauern nach Meldemonat"}
ggplot(df, aes(as.numeric(dauer), fill = DatensatzKategorie)) +
  ester_theme() +
  geom_histogram(position = "dodge", bins = 30) +
  facet_wrap(~Q_Duration, scales = "free", ncol = 3) +
  scale_fill_brewer(palette=mypalette) +
  theme(legend.position = "bottom") +
  xlab("Absonderungsdauer") +
  ylab("Anzahl an Absonderungen")
```


## Graph: Overview over time periods
```{r zeiten, fig.cap="test"}
zeiten <- zeiten %>% 
  mutate(Q_Duration = str_extract(Q_Duration,"\\d+")) %>% 
  mutate(I_Duration = str_extract(I_Duration,"\\d+")) %>% 
  mutate(Q_Def = str_extract(Q_Def,"\\d+"))

graphtabelle <- bind_rows(
  zeiten %>% 
  group_by(Q_Duration) %>% 
  summarise(start = min(dates), end = max(dates)) %>% 
  mutate(group = "Q_Duration") %>% 
  rename(event = Q_Duration),
  zeiten %>% 
  group_by(I_Duration) %>% 
  summarise(start = min(dates), end = max(dates)) %>% 
  mutate(group = "I_Duration") %>% 
  rename(event = I_Duration),
  zeiten %>% 
  group_by(Q_Def) %>% 
  summarise(start = min(dates), end = max(dates)) %>% 
  mutate(group = "Q_Def") %>% 
  rename(event = Q_Def)
  )

gg_vistime(graphtabelle)
```


## Graph: Number of separation orders per person
```{r Anzahl-an-Absonderungen-pro-Person, fig.cap="Anzahl an Absonderungen pro Person"}
p1 <- df %>% group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(n)) +
  ester_theme() +
  geom_bar(fill = brewer.pal(3, mypalette)[3]) +
  coord_cartesian(xlim =c(1, 5)) +
  ggtitle("Anzahl an Isolationen und Quarantänen") 

p2 <- df %>% 
  filter(DatensatzKategorie == "COVID-19") %>% 
  group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(n)) +
  ester_theme() +
  geom_bar(fill = brewer.pal(3, mypalette)[1]) +
  coord_cartesian(xlim =c(1, 5)) +
  ggtitle("Anzahl an Isolationen") 
p3 <- df %>% 
  filter(DatensatzKategorie == "Kontakt-COVID-19") %>% 
  group_by(AnonID) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(n)) +
  ester_theme() +  
  coord_cartesian(xlim =c(1, 5)) +
  geom_bar(fill = brewer.pal(3, mypalette)[2]) +
  ggtitle("Anzahl an Quarantänen") 

p_gesamt <- grid.arrange(p1,p2,p3)
ggsave("graph/zeitenuebersicht.png", p_gesamt)
```


# Linear models
## Linear model of influence an quarantine duration
```{r}
summary(lm(as.numeric(dauer)~AgeGroup+Q_Duration, df %>% filter(DatensatzKategorie == "Kontakt-COVID-19")))
```

## Linear model of influence an isolation duration
```{r}
summary(lm(as.numeric(dauer)~AgeGroup+I_Duration, df %>% filter(DatensatzKategorie == "COVID-19")))
```

